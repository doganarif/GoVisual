{{define "title"}}HTTP Request Visualizer{{end}} {{define "content"}}
<!-- All content is now managed by the layout with sections -->
{{end}} {{define "scripts"}}
<script>
  // Global variables
  let allRequests = [];
  let filteredRequests = [];
  let selectedRequestId = null;

  // Fetch requests initially
  fetch("/__viz/api/requests")
    .then((response) => response.json())
    .then((data) => {
      allRequests = data;
      filteredRequests = [...allRequests];
      updateTable(filteredRequests);
      updateStats(filteredRequests);
    })
    .catch((error) => console.error("Error fetching initial data:", error));

  // Set up SSE for live updates
  const evtSource = new EventSource("/__viz/api/events");
  evtSource.onmessage = function (event) {
    try {
      const data = JSON.parse(event.data);
      allRequests = data;
      applyFilters(); // This will update filteredRequests

      // Save current checkbox states before updating table
      const selectedCheckboxes = {};
      document.querySelectorAll(".request-checkbox").forEach((checkbox) => {
        if (checkbox.checked) {
          selectedCheckboxes[checkbox.getAttribute("data-id")] = true;
        }
      });

      updateTable(filteredRequests);
      updateStats(filteredRequests);

      // Restore checkbox states
      requestAnimationFrame(() => {
        document.querySelectorAll(".request-checkbox").forEach((checkbox) => {
          const id = checkbox.getAttribute("data-id");
          if (selectedCheckboxes[id]) {
            checkbox.checked = true;
          }
        });
      });

      // If details are open, refresh them
      if (
        selectedRequestId &&
        document.getElementById("requestDetails").style.display === "block"
      ) {
        const selectedRequest = allRequests.find(
          (req) => req.ID === selectedRequestId
        );
        if (selectedRequest) {
          showRequestDetails(selectedRequest);
        }
      }

      // Update memory usage
      updateMemoryUsage();
    } catch (error) {
      console.error("Error parsing SSE data:", error);
    }
  };

  // Apply filters to the requests
  function applyFilters() {
    const methodFilter = document.getElementById("method-filter").value;
    const statusFilter = document.getElementById("status-filter").value;
    const pathFilter = document.getElementById("path-filter").value.toLowerCase();
    const durationFilter = document.getElementById("duration-filter").value;
    const typeFilter = document.getElementById("type-filter").value;

    filteredRequests = allRequests.filter((req) => {
      // Type filter (HTTP vs gRPC)
      if (typeFilter && req.Type !== typeFilter) {
        return false;
      }

      // Method filter
      if (methodFilter) {
        if (req.Type === "grpc") {
          // For gRPC, we filter on method type (unary, client_stream, etc.)
          if (req.GRPCMethodType !== methodFilter) {
            return false;
          }
        } else {
          // For HTTP, we filter on HTTP method (GET, POST, etc.)
          if (req.Method !== methodFilter) {
            return false;
          }
        }
      }

      // Status code filter
      if (statusFilter) {
        if (req.Type === "grpc") {
          // gRPC status codes are handled differently
          if (statusFilter === "success" && req.GRPCStatusCode !== 0) {
            return false;
          } else if (statusFilter === "error" && req.GRPCStatusCode === 0) {
            return false;
          } else if (statusFilter.startsWith("code-")) {
            const code = parseInt(statusFilter.substring(5));
            if (req.GRPCStatusCode !== code) {
              return false;
            }
          }
        } else {
          // HTTP status codes
          const firstDigit = Math.floor(req.StatusCode / 100);
          if (statusFilter === "2xx" && firstDigit !== 2) return false;
          if (statusFilter === "3xx" && firstDigit !== 3) return false;
          if (statusFilter === "4xx" && firstDigit !== 4) return false;
          if (statusFilter === "5xx" && firstDigit !== 5) return false;
        }
      }

      // Path/service filter
      if (pathFilter) {
        if (req.Type === "grpc") {
          const servicePath = `${req.GRPCService}/${req.GRPCMethod}`.toLowerCase();
          if (!servicePath.includes(pathFilter)) {
            return false;
          }
        } else {
          if (!req.Path.toLowerCase().includes(pathFilter)) {
            return false;
          }
        }
      }

      // Duration filter - same for both types
      if (
        durationFilter &&
        (!req.Duration || req.Duration < parseInt(durationFilter))
      ) {
        return false;
      }

      return true;
    });
  }

  function showMiddlewareTrace(req) {
    const middlewareList = document.getElementById("middleware-tbody");
    middlewareList.innerHTML = "";

    const middlewareChart = document.getElementById("middleware-chart");
    middlewareChart.innerHTML = "";

    if (!req.MiddlewareTrace || req.MiddlewareTrace.length === 0) {
      const row = document.createElement("tr");
      const cell = document.createElement("td");
      cell.colSpan = 5;
      cell.textContent = "No middleware trace available";
      cell.style.textAlign = "center";
      row.appendChild(cell);
      middlewareList.appendChild(row);
      return;
    }

    // Create a timeline visualization
    const totalDuration = req.Duration;
    const timelineStart = new Date(req.MiddlewareTrace[0].start_time);

    // Add timeline axis
    const timelineAxis = document.createElement("div");
    timelineAxis.className = "timeline-axis";

    // Add timeline ticks
    for (let i = 0; i <= 5; i++) {
      const tick = document.createElement("div");
      tick.className = "timeline-tick";
      tick.style.left = i * 20 + "%";

      const label = document.createElement("div");
      label.className = "timeline-label";
      label.style.left = i * 20 + "%";
      label.textContent = Math.round((totalDuration * i) / 5) + " ms";

      timelineAxis.appendChild(tick);
      timelineAxis.appendChild(label);
    }

    middlewareChart.appendChild(timelineAxis);

    // Sort middleware by start time
    const sortedMiddleware = [...req.MiddlewareTrace].sort(
      (a, b) => a.start_time - b.start_time
    );

    // Render middleware bars
    sortedMiddleware.forEach((mw, index) => {
      const startTime = mw.start_time;
      const endTime = mw.end_time || startTime + mw.duration;
      const duration = mw.duration;

      // Calculate position and width for timeline visualization
      const startPos = ((startTime - timelineStart) / totalDuration) * 100;
      const widthPct = (duration / totalDuration) * 100;

      // Create middleware bar
      const bar = document.createElement("div");
      bar.className = "middleware-bar";
      if (mw.error) {
        bar.className += " error";
      }
      bar.style.left = startPos + "%";
      bar.style.width = Math.max(0.5, widthPct) + "%";
      bar.style.top = index * 25 + "px";
      bar.title = `${mw.name}: ${duration}ms`;

      middlewareChart.appendChild(bar);

      // Populate table
      const row = document.createElement("tr");

      const nameCell = document.createElement("td");
      nameCell.textContent = mw.name;
      row.appendChild(nameCell);

      const durationCell = document.createElement("td");
      durationCell.textContent = duration + " ms";
      row.appendChild(durationCell);

      const startTimeCell = document.createElement("td");
      startTimeCell.textContent =
        new Date(startTime).toLocaleTimeString() +
        "." +
        new Date(startTime).getMilliseconds();
      row.appendChild(startTimeCell);

      const endTimeCell = document.createElement("td");
      endTimeCell.textContent =
        new Date(endTime).toLocaleTimeString() +
        "." +
        new Date(endTime).getMilliseconds();
      row.appendChild(endTimeCell);

      const statusCell = document.createElement("td");
      if (mw.error) {
        statusCell.textContent =
          "Error: " + (mw.error_message || "Unknown error");
        statusCell.className = "status-error";
      } else {
        statusCell.textContent = "Success";
        statusCell.className = "status-success";
      }
      row.appendChild(statusCell);

      middlewareList.appendChild(row);
    });

    // Adjust the height of the chart
    middlewareChart.style.height = sortedMiddleware.length * 25 + 30 + "px";
  }

  // Update the table with the request data
  function updateTable(requests) {
    const tbody = document.getElementById("requestsBody");
    tbody.innerHTML = "";

    if (!requests || requests.length === 0) {
      const row = document.createElement("tr");
      const cell = document.createElement("td");
      cell.colSpan = 5;
      cell.textContent = "No requests logged yet";
      cell.style.textAlign = "center";
      row.appendChild(cell);
      tbody.appendChild(row);
      return;
    }

    // Sort requests by timestamp, newest first
    const sortedRequests = [...requests].sort(
      (a, b) => new Date(b.Timestamp) - new Date(a.Timestamp)
    );

    sortedRequests.forEach((req) => {
      const row = document.createElement("tr");
      row.setAttribute("data-id", req.ID);
      row.setAttribute("data-type", req.Type); // Add type attribute for filtering

      row.addEventListener("click", function (e) {
        // Don't navigate if clicking on a checkbox or its container
        if (
          e.target.classList.contains("request-checkbox") ||
          e.target.classList.contains("request-checkbox-container") ||
          e.target.closest(".request-checkbox-container")
        ) {
          return;
        }

        // Navigate to request details section and show details
        document.querySelector('[data-target="requests-section"]').click();

        // Show appropriate details based on request type
        if (req.Type === "grpc") {
          showGRPCRequestDetails(req);
        } else {
          showRequestDetails(req);
          showRequestTrace(req);
        }
      });

      const timeCell = document.createElement("td");
      timeCell.textContent = new Date(req.Timestamp).toLocaleTimeString();
      row.appendChild(timeCell);

      const typeCell = document.createElement("td");
      if (req.Type === "grpc") {
        typeCell.textContent = "gRPC";
        typeCell.className = "type-grpc";
        row.classList.add("grpc-request"); // Add class for styling
      } else {
        typeCell.textContent = "HTTP";
        typeCell.className = "type-http";
      }
      row.appendChild(typeCell);

      const methodCell = document.createElement("td");
      if (req.Type === "grpc") {
        methodCell.textContent = req.GRPCMethodType || "UNARY";
        methodCell.className = "method-grpc";
      } else {
        methodCell.textContent = req.Method;
        methodCell.className = "method-" + req.Method.toLowerCase();
      }
      row.appendChild(methodCell);

      const pathCell = document.createElement("td");
      if (req.Type === "grpc") {
        pathCell.textContent = `${req.GRPCService}/${req.GRPCMethod}`;
      } else {
        pathCell.textContent = req.Path + (req.Query ? "?" + req.Query : "");
      }
      row.appendChild(pathCell);

      const statusCell = document.createElement("td");
      if (req.Type === "grpc") {
        statusCell.textContent = req.GRPCStatusCode;
        // Add CSS class based on gRPC status code
        if (req.GRPCStatusCode === 0) {
          statusCell.className = "status-success";
        } else {
          statusCell.className = "status-client-error";
        }
      } else {
        statusCell.textContent = req.StatusCode;
        // Add CSS class based on HTTP status code
        if (req.StatusCode >= 200 && req.StatusCode < 300) {
          statusCell.className = "status-success";
        } else if (req.StatusCode >= 300 && req.StatusCode < 400) {
          statusCell.className = "status-redirect";
        } else if (req.StatusCode >= 400 && req.StatusCode < 500) {
          statusCell.className = "status-client-error";
        } else if (req.StatusCode >= 500) {
          statusCell.className = "status-server-error";
        }
      }
      row.appendChild(statusCell);

      const durationCell = document.createElement("td");
      if (req.Duration !== undefined && req.Duration !== null) {
        durationCell.textContent = req.Duration + " ms";
        // Highlight slow requests
        if (req.Duration > 500) {
          durationCell.className = "status-server-error";
        } else if (req.Duration > 200) {
          durationCell.className = "status-client-error";
        }
      } else {
        durationCell.textContent = "N/A";
      }
      row.appendChild(durationCell);

      tbody.appendChild(row);
    });
  }

  // Function to show gRPC request details
  function showGRPCRequestDetails(req) {
    selectedRequestId = req.ID;

    // Hide HTTP-specific trace view
    document.getElementById("traceContainer").style.display = "none";

    // Show gRPC details container
    const grpcDetailsContainer = document.getElementById("grpcRequestDetails");
    if (!grpcDetailsContainer) {
      // Create container if it doesn't exist yet
      createGRPCDetailsContainer();
    }

    document.getElementById("grpcRequestDetails").style.display = "block";
    document.getElementById("requestDetails").style.display = "none"; // Hide HTTP details

    // Fill in basic request information
    document.getElementById("grpc-detail-id").textContent = req.ID;
    document.getElementById("grpc-detail-time").textContent = new Date(
      req.Timestamp
    ).toLocaleString();
    document.getElementById("grpc-detail-service").textContent = req.GRPCService;
    document.getElementById("grpc-detail-method").textContent = req.GRPCMethod;
    document.getElementById("grpc-detail-type").textContent = req.GRPCMethodType;
    document.getElementById("grpc-detail-peer").textContent = req.GRPCPeer || "N/A";

    // Status and error handling
    const statusElement = document.getElementById("grpc-detail-status");
    statusElement.textContent = req.GRPCStatusCode + (req.GRPCStatusDesc ? ` (${req.GRPCStatusDesc})` : "");

    // Apply status styling
    if (req.GRPCStatusCode === 0) {
      statusElement.className = "status-success";
    } else {
      statusElement.className = "status-client-error";
    }

    document.getElementById("grpc-detail-duration").textContent =
      req.Duration !== undefined && req.Duration !== null
        ? req.Duration + " ms"
        : "N/A";

    // Handle error display
    const errorContainer = document.getElementById("grpc-error-container");
    if (req.Error) {
      errorContainer.style.display = "block";
      document.getElementById("grpc-detail-error").textContent = req.Error;
    } else {
      errorContainer.style.display = "none";
    }

    // Format and display metadata
    const requestMDElement = document.getElementById("grpc-detail-request-md");
    requestMDElement.textContent = formatGRPCMetadata(req.GRPCRequestMD);

    const responseMDElement = document.getElementById("grpc-detail-response-md");
    responseMDElement.textContent = formatGRPCMetadata(req.GRPCResponseMD);

    // Handle request and response data
    const requestDataContainer = document.getElementById("grpc-request-data-container");
    const requestDataElement = document.getElementById("grpc-detail-request-data");

    if (req.GRPCRequestData) {
      requestDataContainer.style.display = "block";
      requestDataElement.textContent = formatBody(req.GRPCRequestData);
    } else {
      requestDataContainer.style.display = "none";
    }

    const responseDataContainer = document.getElementById("grpc-response-data-container");
    const responseDataElement = document.getElementById("grpc-detail-response-data");

    if (req.GRPCResponseData) {
      responseDataContainer.style.display = "block";
      responseDataElement.textContent = formatBody(req.GRPCResponseData);
    } else {
      responseDataContainer.style.display = "none";
    }

    // Handle streaming messages if present
    const messagesContainer = document.getElementById("grpc-messages-container");
    const messagesElement = document.getElementById("grpc-messages-list");

    if (req.GRPCMessages && req.GRPCMessages.length > 0) {
      messagesContainer.style.display = "block";
      messagesElement.innerHTML = ""; // Clear previous messages

      // Create a timeline of messages
      req.GRPCMessages.forEach((msg, index) => {
        const msgItem = document.createElement("div");
        msgItem.className = `grpc-message ${msg.Direction === "sent" ? "message-sent" : "message-received"}`;

        const msgHeader = document.createElement("div");
        msgHeader.className = "grpc-message-header";
        msgHeader.innerHTML = `<span class="message-index">#${index + 1}</span> <span class="message-direction">${msg.Direction.toUpperCase()}</span> <span class="message-time">${new Date(msg.Timestamp).toLocaleTimeString()}.${new Date(msg.Timestamp).getMilliseconds()}</span>`;

        const msgContent = document.createElement("pre");
        msgContent.className = "grpc-message-content";
        msgContent.textContent = formatBody(msg.Data);

        msgItem.appendChild(msgHeader);
        msgItem.appendChild(msgContent);
        messagesElement.appendChild(msgItem);
      });
    } else {
      messagesContainer.style.display = "none";
    }
  }

  // Helper function to format GRPC metadata
  function formatGRPCMetadata(metadata) {
    if (!metadata || Object.keys(metadata).length === 0) {
      return "No metadata available";
    }

    let result = "";
    for (const key in metadata) {
      result += `${key}: ${metadata[key].join(", ")}\n`;
    }
    return result;
  }

  // Function to create the gRPC details container if needed
  function createGRPCDetailsContainer() {
    // Create the container element
    const container = document.createElement("div");
    container.id = "grpcRequestDetails";
    container.className = "card";
    container.style.display = "none";

    // Add the content
    container.innerHTML = `
        <div class="card-header">
            <h2>gRPC Request Details</h2>
        </div>
        <div id="grpcDetailsContent">
            <div class="detail-row">
                <strong>ID:</strong> <span id="grpc-detail-id"></span>
            </div>
            <div class="detail-row">
                <strong>Time:</strong> <span id="grpc-detail-time"></span>
            </div>
            <div class="detail-row">
                <strong>Service:</strong> <span id="grpc-detail-service"></span>
            </div>
            <div class="detail-row">
                <strong>Method:</strong> <span id="grpc-detail-method"></span>
            </div>
            <div class="detail-row">
                <strong>Type:</strong> <span id="grpc-detail-type"></span>
            </div>
            <div class="detail-row">
                <strong>Peer:</strong> <span id="grpc-detail-peer"></span>
            </div>
            <div class="detail-row">
                <strong>Status:</strong> <span id="grpc-detail-status"></span>
            </div>
            <div class="detail-row">
                <strong>Duration:</strong> <span id="grpc-detail-duration"></span>
            </div>
            
            <div id="grpc-error-container" style="display: none">
                <h3>Error</h3>
                <pre id="grpc-detail-error" class="error-text"></pre>
            </div>

            <h3>Request Metadata</h3>
            <pre id="grpc-detail-request-md"></pre>

            <h3>Response Metadata</h3>
            <pre id="grpc-detail-response-md"></pre>

            <div id="grpc-request-data-container">
                <h3>Request Data</h3>
                <pre id="grpc-detail-request-data"></pre>
            </div>

            <div id="grpc-response-data-container">
                <h3>Response Data</h3>
                <pre id="grpc-detail-response-data"></pre>
            </div>
            
            <div id="grpc-messages-container">
                <h3>Stream Messages</h3>
                <div id="grpc-messages-list" class="grpc-messages"></div>
            </div>
        </div>
        <button id="close-grpc-details" class="btn">Close Details</button>
    `;

    // Add the container to the requests section
    const requestsSection = document.getElementById("requests-section");
    requestsSection.appendChild(container);

    // Add event listener for close button
    document.getElementById("close-grpc-details").addEventListener("click", () => {
      document.getElementById("grpcRequestDetails").style.display = "none";
      selectedRequestId = null;

      // Return to dashboard section
      document.querySelector('[data-target="dashboard-section"]').click();
    });
  }

  // Update statistics
  function updateStats(requests) {
    if (!requests || requests.length === 0) {
      document.getElementById("stat-total").textContent = "0";
      document.getElementById("stat-success").textContent = "0";
      document.getElementById("stat-redirect").textContent = "0";
      document.getElementById("stat-client-error").textContent = "0";
      document.getElementById("stat-server-error").textContent = "0";
      document.getElementById("stat-grpc-total").textContent = "0";
      document.getElementById("stat-grpc-success").textContent = "0";
      document.getElementById("stat-grpc-error").textContent = "0";
      document.getElementById("stat-avg-time").textContent = "0 ms";

      // Update sidebar stats
      updateSidebarStats(0, 0, 0);
      return;
    }

    // HTTP stats
    let httpSuccess = 0;
    let httpRedirect = 0;
    let httpClientError = 0;
    let httpServerError = 0;
    let httpTotal = 0;

    // gRPC stats
    let grpcSuccess = 0;
    let grpcError = 0;
    let grpcTotal = 0;

    // Shared stats
    let totalDuration = 0;
    let validDurationCount = 0;

    requests.forEach((req) => {
      if (req.Type === "grpc") {
        // gRPC request
        grpcTotal++;

        if (req.GRPCStatusCode === 0) {
          grpcSuccess++;
        } else {
          grpcError++;
        }
      } else {
        // HTTP request
        httpTotal++;

        if (req.StatusCode >= 200 && req.StatusCode < 300) httpSuccess++;
        else if (req.StatusCode >= 300 && req.StatusCode < 400) httpRedirect++;
        else if (req.StatusCode >= 400 && req.StatusCode < 500) httpClientError++;
        else if (req.StatusCode >= 500) httpServerError++;
      }

      if (req.Duration !== undefined && req.Duration !== null) {
        totalDuration += req.Duration;
        validDurationCount++;
      }
    });

    const avgDuration =
      validDurationCount > 0
        ? Math.round(totalDuration / validDurationCount)
        : 0;

    // Calculate combined success rate (HTTP + gRPC)
    const successCount = httpSuccess + grpcSuccess;
    const totalCount = requests.length;
    const successRate = totalCount > 0 ? Math.round((successCount / totalCount) * 100) : 0;

    // Update HTTP stats
    document.getElementById("stat-total").textContent = httpTotal;
    document.getElementById("stat-success").textContent = httpSuccess;
    document.getElementById("stat-redirect").textContent = httpRedirect;
    document.getElementById("stat-client-error").textContent = httpClientError;
    document.getElementById("stat-server-error").textContent = httpServerError;

    // Update gRPC stats
    document.getElementById("stat-grpc-total").textContent = grpcTotal;
    document.getElementById("stat-grpc-success").textContent = grpcSuccess;
    document.getElementById("stat-grpc-error").textContent = grpcError;

    // Update shared stats
    document.getElementById("stat-avg-time").textContent = avgDuration + " ms";

    // Update sidebar stats
    updateSidebarStats(totalCount, successRate, avgDuration);
  }

  function addGRPCStyles() {
    const styleElement = document.createElement('style');
    styleElement.textContent = `
        /* gRPC row styling */
        tr.grpc-request {
            background-color: rgba(76, 175, 80, 0.05);
        }
        
        tr.grpc-request:hover {
            background-color: rgba(76, 175, 80, 0.1);
        }
        
        /* Type indicators */
        .type-grpc {
            color: #4CAF50;
            font-weight: bold;
        }
        
        .type-http {
            color: #2196F3;
            font-weight: bold;
        }
        
        /* Method types */
        .method-grpc {
            color: #9C27B0;
            font-style: italic;
        }
        
        /* gRPC stream messages */
        .grpc-messages {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            margin-top: 10px;
        }
        
        .grpc-message {
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 10px;
            padding-bottom: 10px;
        }
        
        .grpc-message:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .grpc-message-header {
            display: flex;
            justify-content: space-between;
            font-weight: 600;
            padding: 5px 10px;
            background-color: rgba(52, 152, 219, 0.05);
            border-radius: 4px;
            margin-bottom: 5px;
        }
        
        .message-sent .grpc-message-header {
            background-color: rgba(52, 152, 219, 0.1);
        }
        
        .message-received .grpc-message-header {
            background-color: rgba(46, 204, 113, 0.1);
        }
        
        .message-direction {
            color: var(--primary-color);
        }
        
        .message-sent .message-direction {
            color: var(--primary-color);
        }
        
        .message-received .message-direction {
            color: var(--secondary-color);
        }
        
        .grpc-message-content {
            margin: 0;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
        }
        
        /* Error text */
        .error-text {
            color: var(--danger-color);
            background-color: rgba(231, 76, 60, 0.05);
            border-left: 3px solid var(--danger-color);
            padding-left: 10px;
        }
    `;
    document.head.appendChild(styleElement);
  }

  function initializeGRPCSupport() {
    addGRPCStyles();

    // Add type filter to the filters section
    const methodFilterGroup = document.querySelector(".filter-group:first-child");
    if (methodFilterGroup) {
      const typeFilterGroup = document.createElement("div");
      typeFilterGroup.className = "filter-group";
      typeFilterGroup.innerHTML = `
            <label for="type-filter">Request Type</label>
            <select id="type-filter" class="filter-select">
                <option value="">All Types</option>
                <option value="http">HTTP</option>
                <option value="grpc">gRPC</option>
            </select>
        `;

      methodFilterGroup.parentNode.insertBefore(typeFilterGroup, methodFilterGroup);
    }

    // Update method filter to include gRPC method types
    const methodFilter = document.getElementById("method-filter");
    if (methodFilter) {
      // Save current value
      const currentValue = methodFilter.value;

      // Clear options
      methodFilter.innerHTML = "";

      // Add HTTP methods
      const httpOptgroup = document.createElement("optgroup");
      httpOptgroup.label = "HTTP Methods";

      const httpOptions = [
        { value: "", label: "All Methods" },
        { value: "GET", label: "GET" },
        { value: "POST", label: "POST" },
        { value: "PUT", label: "PUT" },
        { value: "DELETE", label: "DELETE" },
        { value: "PATCH", label: "PATCH" }
      ];

      httpOptions.forEach(opt => {
        const option = document.createElement("option");
        option.value = opt.value;
        option.textContent = opt.label;
        if (opt.value === currentValue) {
          option.selected = true;
        }
        httpOptgroup.appendChild(option);
      });

      methodFilter.appendChild(httpOptgroup);

      // Add gRPC method types
      const grpcOptgroup = document.createElement("optgroup");
      grpcOptgroup.label = "gRPC Method Types";

      const grpcOptions = [
        { value: "unary", label: "Unary" },
        { value: "client_stream", label: "Client Streaming" },
        { value: "server_stream", label: "Server Streaming" },
        { value: "bidi_stream", label: "Bidirectional Streaming" }
      ];

      grpcOptions.forEach(opt => {
        const option = document.createElement("option");
        option.value = opt.value;
        option.textContent = opt.label;
        grpcOptgroup.appendChild(option);
      });

      methodFilter.appendChild(grpcOptgroup);
    }

    // Update status filter to include gRPC statuses
    const statusFilter = document.getElementById("status-filter");
    if (statusFilter) {
      // Save current value
      const currentValue = statusFilter.value;

      // Clear options
      statusFilter.innerHTML = "";

      // Add HTTP status codes
      const httpOptgroup = document.createElement("optgroup");
      httpOptgroup.label = "HTTP Status Codes";

      const httpOptions = [
        { value: "", label: "All Status Codes" },
        { value: "2xx", label: "2xx Success" },
        { value: "3xx", label: "3xx Redirect" },
        { value: "4xx", label: "4xx Client Error" },
        { value: "5xx", label: "5xx Server Error" }
      ];

      httpOptions.forEach(opt => {
        const option = document.createElement("option");
        option.value = opt.value;
        option.textContent = opt.label;
        if (opt.value === currentValue) {
          option.selected = true;
        }
        httpOptgroup.appendChild(option);
      });

      statusFilter.appendChild(httpOptgroup);

      // Add gRPC status codes
      const grpcOptgroup = document.createElement("optgroup");
      grpcOptgroup.label = "gRPC Status Codes";

      const grpcOptions = [
        { value: "success", label: "OK (0)" },
        { value: "error", label: "Any Error" },
        { value: "code-1", label: "Cancelled (1)" },
        { value: "code-2", label: "Unknown (2)" },
        { value: "code-3", label: "Invalid Argument (3)" },
        { value: "code-4", label: "Deadline Exceeded (4)" },
        { value: "code-5", label: "Not Found (5)" },
        { value: "code-6", label: "Already Exists (6)" },
        { value: "code-7", label: "Permission Denied (7)" },
        { value: "code-13", label: "Internal (13)" },
        { value: "code-14", label: "Unavailable (14)" }
      ];

      grpcOptions.forEach(opt => {
        const option = document.createElement("option");
        option.value = opt.value;
        option.textContent = opt.label;
        grpcOptgroup.appendChild(option);
      });

      statusFilter.appendChild(grpcOptgroup);
    }

    // Update table headers to add Type column
    const requestsTable = document.getElementById("requests");
    if (requestsTable) {
      const headerRow = requestsTable.querySelector("thead tr");
      if (headerRow) {
        // Look for the Time header
        const timeHeader = headerRow.querySelector("th:first-child");
        if (timeHeader) {
          // Insert Type header after Time
          const typeHeader = document.createElement("th");
          typeHeader.textContent = "Type";
          timeHeader.insertAdjacentElement("afterend", typeHeader);
        }
      }
    }

    // Add gRPC stats to stats section
    const statsGrid = document.querySelector(".stats-grid");
    if (statsGrid) {
      // Create gRPC stat boxes
      const grpcTotalBox = document.createElement("div");
      grpcTotalBox.className = "stat-box";
      grpcTotalBox.innerHTML = `
            <div class="stat-value" id="stat-grpc-total">0</div>
            <div class="stat-label">gRPC Total</div>
        `;

      const grpcSuccessBox = document.createElement("div");
      grpcSuccessBox.className = "stat-box";
      grpcSuccessBox.innerHTML = `
            <div class="stat-value" id="stat-grpc-success">0</div>
            <div class="stat-label">gRPC Success</div>
        `;

      const grpcErrorBox = document.createElement("div");
      grpcErrorBox.className = "stat-box";
      grpcErrorBox.innerHTML = `
            <div class="stat-value" id="stat-grpc-error">0</div>
            <div class="stat-label">gRPC Errors</div>
        `;

      // Append to stats grid
      statsGrid.appendChild(grpcTotalBox);
      statsGrid.appendChild(grpcSuccessBox);
      statsGrid.appendChild(grpcErrorBox);
    }

    // Create the gRPC details container
    createGRPCDetailsContainer();
  }

  // Show request details
  function showRequestDetails(req) {
    selectedRequestId = req.ID;

    document.getElementById("detail-id").textContent = req.ID;
    document.getElementById("detail-time").textContent = new Date(
      req.Timestamp
    ).toLocaleString();
    document.getElementById("detail-method").textContent = req.Method;
    document.getElementById("detail-path").textContent =
      req.Path + (req.Query ? "?" + req.Query : "");
    document.getElementById("detail-status").textContent = req.StatusCode;
    document.getElementById("detail-duration").textContent =
      req.Duration !== undefined && req.Duration !== null
        ? req.Duration + " ms"
        : "N/A";

    // Try to add replay button safely
    try {
      const detailHeader = document.querySelector(
        "#requestDetails .card-header"
      );
      if (detailHeader && !document.getElementById("replayRequestBtn")) {
        const replayBtn = document.createElement("button");
        replayBtn.id = "replayRequestBtn";
        replayBtn.className = "btn";
        replayBtn.style.marginLeft = "10px";
        replayBtn.textContent = "Replay Request";
        replayBtn.addEventListener("click", () => {
          openReplayModal(req);
        });
        detailHeader.appendChild(replayBtn);
      }
    } catch (e) {
      console.error("Could not add replay button:", e);
    }

    // Format headers
    const requestHeaders = formatHeaders(req.RequestHeaders);
    const responseHeaders = formatHeaders(req.ResponseHeaders);

    document.getElementById("detail-request-headers").textContent =
      requestHeaders || "No headers available";
    document.getElementById("detail-response-headers").textContent =
      responseHeaders || "No headers available";

    // Handle request and response bodies
    const requestBodyContainer = document.getElementById(
      "request-body-container"
    );
    const responseBodyContainer = document.getElementById(
      "response-body-container"
    );
    const requestBodyElement = document.getElementById("detail-request-body");
    const responseBodyElement = document.getElementById("detail-response-body");

    if (req.RequestBody) {
      requestBodyContainer.style.display = "block";
      requestBodyElement.textContent = formatBody(req.RequestBody);
    } else {
      requestBodyContainer.style.display = "none";
    }

    if (req.ResponseBody) {
      responseBodyContainer.style.display = "block";
      responseBodyElement.textContent = formatBody(req.ResponseBody);
    } else {
      responseBodyContainer.style.display = "none";
    }

    // Show the details
    document.getElementById("requestDetails").style.display = "block";
  }

  // Show request trace
  function showRequestTrace(req) {
    const traceContainer = document.getElementById("traceContainer");
    traceContainer.style.display = "block";

    // Update the trace timing information
    document.getElementById("trace-total-time").textContent = req.Duration
      ? req.Duration + " ms"
      : "N/A";

    // These values would be populated if we had more detailed timing data
    const duration = req.Duration || 0;
    document.getElementById("trace-ttfb").textContent =
      Math.round(duration * 0.2) + " ms";
    document.getElementById("trace-network-time").textContent =
      Math.round(duration * 0.1) + " ms";
    document.getElementById("trace-processing-time").textContent =
      Math.round(duration * 0.7) + " ms";

    // Populate timeline (would need more detailed timing data)
    const timelineContent = document.getElementById("timeline-content");
    timelineContent.innerHTML = "";

    // Example phases - in a real implementation, this would come from detailed tracing
    const phases = [
      { name: "Connection", duration: Math.round(duration * 0.05) },
      { name: "Request Processing", duration: Math.round(duration * 0.15) },
      { name: "Handler Execution", duration: Math.round(duration * 0.7) },
      { name: "Response Generation", duration: Math.round(duration * 0.1) },
    ];

    phases.forEach((phase) => {
      const timelineItem = document.createElement("div");
      timelineItem.className = "timeline-item";

      const phaseName = document.createElement("div");
      phaseName.textContent = phase.name;

      const phaseDuration = document.createElement("div");
      phaseDuration.textContent = phase.duration + " ms";

      timelineItem.appendChild(phaseName);
      timelineItem.appendChild(phaseDuration);
      timelineContent.appendChild(timelineItem);
    });

    // Show middleware trace
    showMiddlewareTrace(req);

    // Show route trace if available
    if (req.RouteTrace) {
      document.getElementById("trace-route-match").style.display = "block";
      const routeDetails = document.getElementById("trace-route-details");
      routeDetails.innerHTML = "";

      const routePattern = document.createElement("div");
      routePattern.className = "trace-detail-item";
      routePattern.innerHTML = `<strong>Pattern:</strong> ${req.RouteTrace.pattern || "Unknown"
        }`;
      routeDetails.appendChild(routePattern);

      const routePath = document.createElement("div");
      routePath.className = "trace-detail-item";
      routePath.innerHTML = `<strong>Path:</strong> ${req.RouteTrace.path || "Unknown"
        }`;
      routeDetails.appendChild(routePath);

      if (req.RouteTrace.params) {
        const paramsTitle = document.createElement("div");
        paramsTitle.className = "trace-detail-item";
        paramsTitle.innerHTML = `<strong>Parameters:</strong>`;
        routeDetails.appendChild(paramsTitle);

        const paramsList = document.createElement("ul");
        paramsList.className = "route-params-list";

        for (const [key, value] of Object.entries(req.RouteTrace.params)) {
          const paramItem = document.createElement("li");
          paramItem.innerHTML = `<strong>${key}:</strong> ${value}`;
          paramsList.appendChild(paramItem);
        }

        routeDetails.appendChild(paramsList);
      }
    } else {
      document.getElementById("trace-route-match").style.display = "none";
    }
  }

  // Format headers for display
  function formatHeaders(headers) {
    if (!headers) return "";

    let result = "";
    for (const key in headers) {
      result += `${key}: ${headers[key].join(", ")}\n`;
    }
    return result;
  }

  // Format body for display
  function formatBody(body) {
    try {
      // Try to parse and pretty-print JSON
      const json = JSON.parse(body);
      return JSON.stringify(json, null, 2);
    } catch (e) {
      // If not JSON, return as-is
      return body;
    }
  }

  // Update memory usage (simulated for now)
  function updateMemoryUsage() {
    // In a real implementation, this would get data from the server
    const usedMemory = Math.random() * 2000; // Simulated memory usage (MB)
    const totalMemory = 8192; // Simulated total memory (MB)
    const percentage = (usedMemory / totalMemory) * 100;

    document.getElementById("memory-used").style.width = percentage + "%";
    document.getElementById("memory-used-value").textContent =
      Math.round(usedMemory) + " MB";
    document.getElementById("memory-total").textContent =
      Math.round(totalMemory) + " MB";
  }

  // Toggle collapse function for collapsible sections
  function toggleCollapse(element) {
    const card = element.closest(".collapsible");
    card.classList.toggle("collapsed");
  }

  // Close details
  document.getElementById("close-details").addEventListener("click", () => {
    document.getElementById("requestDetails").style.display = "none";
    document.getElementById("traceContainer").style.display = "none";
    selectedRequestId = null;

    // Return to dashboard section
    document.querySelector('[data-target="dashboard-section"]').click();
  });

  // Clear all requests function
  function clearAllRequests() {
    if (confirm("Are you sure you want to clear all requests?")) {
      // In a real implementation, this would call an API endpoint to clear the requests
      fetch("/__viz/api/clear", {
        method: "POST",
      })
        .then((response) => {
          if (response.ok) {
            // Clear local data
            allRequests = [];
            filteredRequests = [];
            updateTable(filteredRequests);
            updateStats(filteredRequests);

            // Hide details if open
            document.getElementById("requestDetails").style.display = "none";
            document.getElementById("traceContainer").style.display = "none";
            selectedRequestId = null;
          }
        })
        .catch((error) => console.error("Error clearing requests:", error));
    }
  }

  // Set up filter actions
  document.getElementById("apply-filters").addEventListener("click", () => {
    applyFilters();
    updateTable(filteredRequests);
    updateStats(filteredRequests);
  });

  document.getElementById("reset-filters").addEventListener("click", () => {
    // Reset filter inputs
    document.getElementById("method-filter").value = "";
    document.getElementById("status-filter").value = "";
    document.getElementById("path-filter").value = "";
    document.getElementById("duration-filter").value = "";

    // Reset filtered data
    filteredRequests = [...allRequests];
    updateTable(filteredRequests);
    updateStats(filteredRequests);
  });

  document
    .getElementById("clear-requests")
    .addEventListener("click", clearAllRequests);

  // Initial memory usage update
  updateMemoryUsage();

  // Set up periodic memory usage updates
  setInterval(updateMemoryUsage, 5000);

  // Request comparison functionality
  let selectedRequests = [];
  const maxCompareRequests = 2; // Maximum number of requests to compare

  // Add checkbox to request rows for selection
  function addSelectionToTable() {
    const rows = document.querySelectorAll("#requestsBody tr");
    rows.forEach((row) => {
      // Skip rows that don't have data
      if (!row.hasAttribute("data-id")) {
        return;
      }

      // Don't add checkboxes twice
      if (row.querySelector(".request-checkbox")) {
        return;
      }

      const requestId = row.getAttribute("data-id");
      const firstCell = row.querySelector("td:first-child");

      // Create checkbox container
      const checkboxContainer = document.createElement("div");
      checkboxContainer.style.display = "inline-block";
      checkboxContainer.style.marginRight = "10px";
      checkboxContainer.className = "request-checkbox-container";

      // Prevent event bubbling for the container
      checkboxContainer.addEventListener("click", function (e) {
        e.stopPropagation();
      });

      // Create checkbox
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "request-checkbox";
      checkbox.setAttribute("data-id", requestId);

      // Check if this request is already in selectedRequests
      if (selectedRequests.includes(requestId)) {
        checkbox.checked = true;
        row.classList.add("selected-for-comparison");
      }

      // Handle checkbox events
      checkbox.addEventListener("click", function (e) {
        e.stopPropagation(); // This is critical - stop click from bubbling to parent row
      });

      checkbox.addEventListener("change", function (e) {
        e.stopPropagation();
        toggleRequestSelection(requestId);
      });

      // Add to DOM
      checkboxContainer.appendChild(checkbox);
      firstCell.insertBefore(checkboxContainer, firstCell.firstChild);
    });
  }

  // Toggle request selection
  function toggleRequestSelection(requestId) {
    const index = selectedRequests.indexOf(requestId);
    const row = document.querySelector(`tr[data-id="${requestId}"]`);

    if (index === -1) {
      // Add to selection if not already at maximum
      if (selectedRequests.length < maxCompareRequests) {
        selectedRequests.push(requestId);
        addToSelectedList(requestId);
        if (row) row.classList.add("selected-for-comparison");
      } else {
        alert(
          `Maximum of ${maxCompareRequests} requests can be compared at once.`
        );
        // Uncheck the checkbox
        document.querySelector(
          `.request-checkbox[data-id="${requestId}"]`
        ).checked = false;
        return;
      }
    } else {
      // Remove from selection
      selectedRequests.splice(index, 1);
      removeFromSelectedList(requestId);
      if (row) row.classList.remove("selected-for-comparison");
    }

    updateCompareButton();
  }

  // Add request to the selected list
  function addToSelectedList(requestId) {
    const selectedList = document.getElementById("selectedRequestsList");
    const placeholder = document.querySelector(".compare-placeholder");

    if (placeholder) {
      placeholder.remove();
    }

    // Find the request in allRequests
    const request = allRequests.find((req) => req.ID === requestId);
    if (!request) return;

    const item = document.createElement("div");
    item.className = "compare-item";
    item.setAttribute("data-id", requestId);
    item.innerHTML = `
            <span>${request.Method} ${request.Path}</span>
            <span class="remove-item" data-id="${requestId}">&times;</span>
        `;

    item.querySelector(".remove-item").addEventListener("click", function () {
      const id = this.getAttribute("data-id");
      // Uncheck the checkbox
      const checkbox = document.querySelector(
        `.request-checkbox[data-id="${id}"]`
      );
      if (checkbox) checkbox.checked = false;
      toggleRequestSelection(id);
    });

    selectedList.appendChild(item);
  }

  // Remove request from the selected list
  function removeFromSelectedList(requestId) {
    const item = document.querySelector(
      `.compare-item[data-id="${requestId}"]`
    );
    if (item) {
      item.remove();
    }

    // Show placeholder if no items left
    const selectedList = document.getElementById("selectedRequestsList");
    if (selectedList.children.length === 0) {
      const placeholder = document.createElement("div");
      placeholder.className = "compare-placeholder";
      placeholder.textContent = "Select 2 or more requests to compare";
      selectedList.appendChild(placeholder);
    }
  }

  // Update the compare button visibility
  function updateCompareButton() {
    const compareBtn = document.getElementById("diff-compare-btn");

    if (selectedRequests.length >= 2) {
      compareBtn.classList.add("active");
      document.getElementById("comparePanel").style.display = "block";
    } else {
      compareBtn.classList.remove("active");
    }
  }

  // Run the comparison
  function runComparison() {
    if (selectedRequests.length < 2) {
      alert("Please select at least 2 requests to compare.");
      return;
    }

    // Build query string with selected request IDs
    const queryString = selectedRequests.map((id) => `id=${id}`).join("&");

    // Fetch comparison data
    fetch(`/__viz/api/compare?${queryString}`)
      .then((response) => response.json())
      .then((requests) => {
        displayComparison(requests);
      })
      .catch((error) => {
        console.error("Error fetching comparison data:", error);
        alert("An error occurred while fetching comparison data.");
      });
  }

  // Display the comparison
  function displayComparison(requests) {
    const resultsContainer = document.getElementById("comparisonResults");
    resultsContainer.innerHTML = "";

    if (requests.length < 2) {
      resultsContainer.innerHTML = "<p>Not enough requests for comparison.</p>";
      return;
    }

    // Check if we have potentially related routes (same pattern with different parameters)
    const routePatterns = detectRoutePatterns(requests);
    const hasRelatedRoutes = Object.keys(routePatterns).length > 0;

    // Create a column for each request
    requests.forEach((request, index) => {
      const column = document.createElement("div");
      column.className = "compare-column";

      // Column header
      const header = document.createElement("div");
      header.className = "compare-column-header";
      header.textContent = `${request.Method} ${request.Path}`;
      if (index === 0) {
        header.textContent += " (Base for comparison)";
      }
      column.appendChild(header);

      // Column content
      const content = document.createElement("div");
      content.className = "compare-column-content";

      // Add basic details
      addCompareDetailRow(content, "ID", request.ID);
      addCompareDetailRow(content, "Method", request.Method);
      addCompareDetailRow(content, "Path", request.Path);

      // Add route pattern information if available
      if (hasRelatedRoutes) {
        const patternKey = findPatternForRequest(routePatterns, request.Path);
        if (patternKey) {
          const pattern = routePatterns[patternKey].pattern;
          const params = extractRouteParams(pattern, request.Path);

          if (pattern) {
            addCompareDetailRow(content, "Route Pattern", pattern);
          }

          if (params && Object.keys(params).length > 0) {
            let paramsText = "";
            for (const [key, value] of Object.entries(params)) {
              paramsText += `${key}: ${value}\n`;
            }
            addCompareDetailRow(content, "Route Parameters", paramsText);
          }
        }
      }

      // Continue with other details
      addCompareDetailRow(content, "Status", request.StatusCode);
      addCompareDetailRow(content, "Time", `${request.Duration} ms`);
      addCompareDetailRow(
        content,
        "Timestamp",
        new Date(request.Timestamp).toLocaleString()
      );

      // Add request headers
      if (request.RequestHeaders) {
        if (index === 0 || !requests[0].RequestHeaders) {
          addCompareDetailRow(
            content,
            "Request Headers",
            formatHeaders(request.RequestHeaders)
          );
        } else {
          // Compare with first request's headers
          addCompareDetailRow(
            content,
            "Request Headers",
            compareHeaders(requests[0].RequestHeaders, request.RequestHeaders)
          );
        }
      }

      // Add response headers
      if (request.ResponseHeaders) {
        if (index === 0 || !requests[0].ResponseHeaders) {
          addCompareDetailRow(
            content,
            "Response Headers",
            formatHeaders(request.ResponseHeaders)
          );
        } else {
          // Compare with first request's headers
          addCompareDetailRow(
            content,
            "Response Headers",
            compareHeaders(requests[0].ResponseHeaders, request.ResponseHeaders)
          );
        }
      }

      // Add request body with JSON diff if possible
      if (request.RequestBody) {
        if (index === 0 || !requests[0].RequestBody) {
          addCompareDetailRow(
            content,
            "Request Body",
            formatBody(request.RequestBody)
          );
        } else {
          try {
            // Try to parse as JSON for diff
            const baseJson = JSON.parse(requests[0].RequestBody);
            const currentJson = JSON.parse(request.RequestBody);
            addCompareDetailRow(
              content,
              "Request Body (with diffs)",
              formatJsonDiff(baseJson, currentJson)
            );
          } catch (e) {
            // Fall back to regular display if not valid JSON
            addCompareDetailRow(
              content,
              "Request Body",
              formatBody(request.RequestBody)
            );
          }
        }
      }

      // Add response body with JSON diff if possible
      if (request.ResponseBody) {
        if (index === 0 || !requests[0].ResponseBody) {
          addCompareDetailRow(
            content,
            "Response Body",
            formatBody(request.ResponseBody)
          );
        } else {
          try {
            // Try to parse as JSON for diff
            const baseJson = JSON.parse(requests[0].ResponseBody);
            const currentJson = JSON.parse(request.ResponseBody);
            addCompareDetailRow(
              content,
              "Response Body (with diffs)",
              formatJsonDiff(baseJson, currentJson)
            );
          } catch (e) {
            // Fall back to regular display if not valid JSON
            addCompareDetailRow(
              content,
              "Response Body",
              formatBody(request.ResponseBody)
            );
          }
        }
      }

      column.appendChild(content);
      resultsContainer.appendChild(column);
    });

    // Show the comparison panel
    document.getElementById("comparePanel").classList.add("active");
  }

  // Compare headers and highlight differences
  function compareHeaders(baseHeaders, compareHeaders) {
    let result = "";
    const allKeys = new Set();

    // Collect all keys from both objects
    for (const key in baseHeaders) allKeys.add(key);
    for (const key in compareHeaders) allKeys.add(key);

    // Sort keys alphabetically
    const sortedKeys = Array.from(allKeys).sort();

    sortedKeys.forEach((key) => {
      const baseValue = baseHeaders[key]
        ? baseHeaders[key].join(", ")
        : undefined;
      const compareValue = compareHeaders[key]
        ? compareHeaders[key].join(", ")
        : undefined;

      if (!baseValue) {
        // New header in the comparison
        result += `<span class="diff-add">${key}: ${compareValue}</span>\n`;
      } else if (!compareValue) {
        // Header removed in the comparison
        result += `${key}: [removed]\n`;
      } else if (baseValue !== compareValue) {
        // Header value changed
        result += `${key}: <span class="diff-highlight">${compareValue}</span>\n`;
      } else {
        // Same value
        result += `${key}: ${compareValue}\n`;
      }
    });

    return result;
  }

  // Format JSON diff
  function formatJsonDiff(baseJson, compareJson, path = "") {
    let output = "";

    if (Array.isArray(baseJson) && Array.isArray(compareJson)) {
      // Handle arrays
      const maxLength = Math.max(baseJson.length, compareJson.length);

      output += "[\n";
      for (let i = 0; i < maxLength; i++) {
        const currentPath = path ? `${path}[${i}]` : `[${i}]`;
        const indent = "  ".repeat(currentPath.split(/[\[\].]+/).length);

        if (i < baseJson.length && i < compareJson.length) {
          // Both arrays have this index
          output += indent;
          if (
            typeof baseJson[i] === "object" &&
            baseJson[i] !== null &&
            typeof compareJson[i] === "object" &&
            compareJson[i] !== null
          ) {
            // Both are objects, recursively diff
            output += formatJsonDiff(baseJson[i], compareJson[i], currentPath);
          } else if (baseJson[i] !== compareJson[i]) {
            // Primitive values that differ
            output += `<span class="diff-highlight">${JSON.stringify(
              compareJson[i]
            )}</span>`;
          } else {
            // Same values
            output += JSON.stringify(compareJson[i]);
          }
        } else if (i >= baseJson.length) {
          // Item only in compareJson
          output +=
            indent +
            `<span class="diff-add">${JSON.stringify(compareJson[i])}</span>`;
        } else {
          // Item in baseJson but not in compareJson
          output += indent + `[removed]`;
        }

        if (i < maxLength - 1) {
          output += ",";
        }
        output += "\n";
      }
      output += "  ".repeat(path.split(/[\[\].]+/).length - 1) + "]";
    } else if (
      typeof baseJson === "object" &&
      baseJson !== null &&
      typeof compareJson === "object" &&
      compareJson !== null
    ) {
      // Handle objects
      const allKeys = new Set();
      Object.keys(baseJson).forEach((key) => allKeys.add(key));
      Object.keys(compareJson).forEach((key) => allKeys.add(key));

      const sortedKeys = Array.from(allKeys).sort();

      output += "{\n";
      sortedKeys.forEach((key, index) => {
        const currentPath = path ? `${path}.${key}` : key;
        const indent = "  ".repeat(currentPath.split(/[\[\].]+/).length);

        output += indent + `"${key}": `;

        if (key in baseJson && key in compareJson) {
          // Key in both objects
          if (
            typeof baseJson[key] === "object" &&
            baseJson[key] !== null &&
            typeof compareJson[key] === "object" &&
            compareJson[key] !== null
          ) {
            // Both are objects, recursively diff
            output += formatJsonDiff(
              baseJson[key],
              compareJson[key],
              currentPath
            );
          } else if (baseJson[key] !== compareJson[key]) {
            // Primitive values that differ
            output += `<span class="diff-highlight">${JSON.stringify(
              compareJson[key]
            )}</span>`;
          } else {
            // Same values
            output += JSON.stringify(compareJson[key]);
          }
        } else if (!(key in baseJson)) {
          // Key only in compareJson
          output += `<span class="diff-add">${JSON.stringify(
            compareJson[key]
          )}</span>`;
        } else {
          // Key in baseJson but not in compareJson
          output += `[removed]`;
        }

        if (index < sortedKeys.length - 1) {
          output += ",";
        }
        output += "\n";
      });
      output += "  ".repeat(path.split(/[\[\].]+/).length - 1) + "}";
    } else {
      // Handle primitive values
      if (baseJson !== compareJson) {
        output += `<span class="diff-highlight">${JSON.stringify(
          compareJson
        )}</span>`;
      } else {
        output += JSON.stringify(compareJson);
      }
    }

    return output;
  }

  // Add a detail row to the comparison
  function addCompareDetailRow(container, label, value) {
    const row = document.createElement("div");
    row.className = "compare-detail-row";

    const labelElement = document.createElement("div");
    labelElement.className = "compare-detail-label";
    labelElement.textContent = label;

    const valueElement = document.createElement("div");
    valueElement.className = "compare-detail-value";

    if (typeof value === "string") {
      // Check if value contains HTML for diff highlighting
      if (value.includes("<span class=")) {
        if (value.includes("\n")) {
          // Multiline HTML content
          const pre = document.createElement("pre");
          pre.innerHTML = value;
          valueElement.appendChild(pre);
        } else {
          // Single line HTML content
          valueElement.innerHTML = value;
        }
      } else if (value.includes("\n")) {
        // Regular multiline text, use pre element
        const pre = document.createElement("pre");
        pre.textContent = value;
        valueElement.appendChild(pre);
      } else {
        // Regular single line text
        valueElement.textContent = value;
      }
    } else {
      valueElement.textContent = value;
    }

    row.appendChild(labelElement);
    row.appendChild(valueElement);
    container.appendChild(row);
  }

  // Event Listeners
  document
    .getElementById("diff-compare-btn")
    .addEventListener("click", function () {
      document.getElementById("comparePanel").classList.add("active");
    });

  document
    .getElementById("closeCompare")
    .addEventListener("click", function () {
      document.getElementById("comparePanel").classList.remove("active");
    });

  document
    .getElementById("runComparison")
    .addEventListener("click", runComparison);

  // Initialize comparison UI
  function initComparisonUI() {
    addSelectionToTable();
  }

  // Call initialization after table updates
  const originalUpdateTable = updateTable;
  updateTable = function (requests) {
    originalUpdateTable(requests);
    initComparisonUI();
  };

  // Initialize on page load
  initComparisonUI();

  // Detect route patterns in the requests
  function detectRoutePatterns(requests) {
    const patterns = {};

    // Example path patterns to detect:
    // /api/users/123 and /api/users/456 => /api/users/:id
    // /api/products/electronics/tv and /api/products/furniture/chair => /api/products/:category/:item

    // Simple rule-based pattern detection - this could be improved with more sophisticated algorithms
    requests.forEach((req) => {
      const path = req.Path;
      const segments = path.split("/").filter(Boolean);

      // Look for numeric segments (likely IDs)
      for (let i = 0; i < segments.length; i++) {
        if (/^\d+$/.test(segments[i])) {
          // Create a pattern with this segment replaced by :id
          const patternSegments = [...segments];
          patternSegments[i] = ":id";
          const pattern = "/" + patternSegments.join("/");

          // Store the pattern
          if (!patterns[pattern]) {
            patterns[pattern] = {
              pattern: pattern,
              paths: [],
            };
          }

          patterns[pattern].paths.push(path);
          break; // Only detect one parameter per path for now
        }

        // Look for UUID-like segments
        if (
          /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(
            segments[i]
          )
        ) {
          // Create a pattern with this segment replaced by :uuid
          const patternSegments = [...segments];
          patternSegments[i] = ":uuid";
          const pattern = "/" + patternSegments.join("/");

          // Store the pattern
          if (!patterns[pattern]) {
            patterns[pattern] = {
              pattern: pattern,
              paths: [],
            };
          }

          patterns[pattern].paths.push(path);
          break;
        }
      }
    });

    // Only return patterns that match multiple paths
    return Object.fromEntries(
      Object.entries(patterns).filter(([_, value]) => value.paths.length > 1)
    );
  }

  // Find the pattern for a specific request path
  function findPatternForRequest(patterns, path) {
    for (const [patternKey, patternData] of Object.entries(patterns)) {
      if (patternData.paths.includes(path)) {
        return patternKey;
      }
    }
    return null;
  }

  // Extract route parameters from a path based on a pattern
  function extractRouteParams(pattern, path) {
    const patternSegments = pattern.split("/").filter(Boolean);
    const pathSegments = path.split("/").filter(Boolean);

    if (patternSegments.length !== pathSegments.length) {
      return null;
    }

    const params = {};

    for (let i = 0; i < patternSegments.length; i++) {
      if (patternSegments[i].startsWith(":")) {
        const paramName = patternSegments[i].substring(1);
        params[paramName] = pathSegments[i];
      }
    }

    return params;
  }

  // Open replay modal with request data
  function openReplayModal(req) {
    // Set request ID
    document.getElementById("replayRequestId").value = req.ID;

    // Set URL (combine path and query)
    const url =
      window.location.origin + req.Path + (req.Query ? `?${req.Query}` : "");
    document.getElementById("replayUrl").value = url;

    // Set method
    document.getElementById("replayMethod").value = req.Method;

    // Populate headers
    const headersBody = document.getElementById("replayHeadersBody");
    headersBody.innerHTML = "";

    if (req.RequestHeaders) {
      for (const [key, values] of Object.entries(req.RequestHeaders)) {
        // Skip certain headers that browsers control
        if (
          [
            "Host",
            "Connection",
            "Upgrade-Insecure-Requests",
            "Sec-Fetch-",
            "Accept-Encoding",
          ].some((h) => key.startsWith(h))
        ) {
          continue;
        }

        addHeaderRow(key, values.join(", "));
      }
    }

    // Set body
    document.getElementById("replayBody").value = req.RequestBody || "";

    // Reset result section
    document.getElementById("replayResult").classList.remove("active");

    // Show modal
    document.getElementById("replayModal").classList.add("active");
  }

  // Add a header row to the table
  function addHeaderRow(name = "", value = "") {
    const headersBody = document.getElementById("replayHeadersBody");
    const row = document.createElement("tr");

    row.innerHTML = `
        <td><input type="text" class="header-name" value="${escapeHtml(
      name
    )}" placeholder="Header name"></td>
        <td><input type="text" class="header-value" value="${escapeHtml(
      value
    )}" placeholder="Header value"></td>
        <td><span class="replay-remove-header">&times;</span></td>
    `;

    row
      .querySelector(".replay-remove-header")
      .addEventListener("click", function () {
        row.remove();
      });

    headersBody.appendChild(row);
  }

  // Send the replay request
  function sendReplayRequest(e) {
    e.preventDefault();

    // Collect form data
    const requestId = document.getElementById("replayRequestId").value;
    const url = document.getElementById("replayUrl").value;
    const method = document.getElementById("replayMethod").value;
    const body = document.getElementById("replayBody").value;

    // Collect headers
    const headers = {};
    const headerRows = document.querySelectorAll("#replayHeadersBody tr");
    headerRows.forEach((row) => {
      const nameInput = row.querySelector(".header-name");
      const valueInput = row.querySelector(".header-value");

      if (nameInput.value) {
        headers[nameInput.value] = valueInput.value;
      }
    });

    // Prepare request data
    const requestData = {
      requestId,
      url,
      method,
      headers,
      body,
    };

    // Show loading
    const sendButton = document.getElementById("sendReplayRequest");
    const originalText = sendButton.textContent;
    sendButton.innerHTML = '<span class="replay-spinner"></span> Sending...';
    sendButton.disabled = true;

    // Send request to server
    fetch("/__viz/api/replay", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestData),
    })
      .then((response) => response.json())
      .then((data) => {
        // Display results
        displayReplayResult(data);
      })
      .catch((error) => {
        console.error("Error replaying request:", error);
        alert("Error replaying request: " + error.message);
      })
      .finally(() => {
        // Reset button
        sendButton.innerHTML = originalText;
        sendButton.disabled = false;
      });
  }

  // Display replay results
  function displayReplayResult(data) {
    // Show result section
    const resultSection = document.getElementById("replayResult");
    resultSection.classList.add("active");

    // Set status info
    const statusElement = document.getElementById("replayResponseStatus");
    const statusBadge = document.getElementById("replayStatusBadge");
    statusElement.textContent = `${data.statusCode} ${getStatusText(
      data.statusCode
    )}`;

    if (data.statusCode >= 200 && data.statusCode < 300) {
      statusBadge.textContent = "Success";
      statusBadge.className = "replay-status replay-status-success";
    } else {
      statusBadge.textContent = "Error";
      statusBadge.className = "replay-status replay-status-error";
    }

    // Set duration
    document.getElementById("replayResponseDuration").textContent =
      data.duration;

    // Set headers
    const headersText = formatHeadersForDisplay(data.headers);
    document.getElementById("replayResponseHeaders").textContent = headersText;

    // Set body
    const bodyElement = document.getElementById("replayResponseBody");

    try {
      // Try to format as JSON if possible
      const json = JSON.parse(data.body);
      bodyElement.textContent = JSON.stringify(json, null, 2);
    } catch (e) {
      // Not JSON, display as is
      bodyElement.textContent = data.body;
    }

    // Scroll to results
    resultSection.scrollIntoView({ behavior: "smooth" });
  }

  // Format headers for display in the replay results
  function formatHeadersForDisplay(headers) {
    if (!headers) return "No headers";

    let output = "";
    for (const [key, values] of Object.entries(headers)) {
      output += `${key}: ${Array.isArray(values) ? values.join(", ") : values
        }\n`;
    }

    return output;
  }

  // Get HTTP status text
  function getStatusText(code) {
    const statusTexts = {
      100: "Continue",
      101: "Switching Protocols",
      200: "OK",
      201: "Created",
      202: "Accepted",
      204: "No Content",
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Found",
      304: "Not Modified",
      400: "Bad Request",
      401: "Unauthorized",
      403: "Forbidden",
      404: "Not Found",
      405: "Method Not Allowed",
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
    };

    return statusTexts[code] || "";
  }

  // HTML escape helper
  function escapeHtml(str) {
    if (!str) return "";
    return str
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  // Set up event listeners for replay modal
  document.getElementById("addHeaderRow").addEventListener("click", () => {
    addHeaderRow();
  });

  document
    .getElementById("replayForm")
    .addEventListener("submit", sendReplayRequest);

  document.getElementById("closeReplayModal").addEventListener("click", () => {
    document.getElementById("replayModal").classList.remove("active");
  });

  // Close modal if clicking outside the content
  document.getElementById("replayModal").addEventListener("click", (e) => {
    if (e.target === document.getElementById("replayModal")) {
      document.getElementById("replayModal").classList.remove("active");
    }
  });

  document.addEventListener("DOMContentLoaded", initializeGRPCSupport);
</script>
{{end}}