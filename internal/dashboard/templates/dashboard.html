{{define "title"}}HTTP Request Visualizer{{end}} {{define "content"}}
<!-- All content is now managed by the layout with sections -->
{{end}} {{define "scripts"}}
<script>
  // Global variables
  let allRequests = [];
  let filteredRequests = [];
  let selectedRequestId = null;

  // Fetch requests initially
  fetch("/__viz/api/requests")
    .then((response) => response.json())
    .then((data) => {
      allRequests = data;
      filteredRequests = [...allRequests];
      updateTable(filteredRequests);
      updateStats(filteredRequests);
    })
    .catch((error) => console.error("Error fetching initial data:", error));

  // Set up SSE for live updates
  const evtSource = new EventSource("/__viz/api/events");
  evtSource.onmessage = function (event) {
    try {
      const data = JSON.parse(event.data);
      allRequests = data;
      applyFilters(); // This will update filteredRequests

      // Save current checkbox states before updating table
      const selectedCheckboxes = {};
      document.querySelectorAll(".request-checkbox").forEach((checkbox) => {
        if (checkbox.checked) {
          selectedCheckboxes[checkbox.getAttribute("data-id")] = true;
        }
      });

      updateTable(filteredRequests);
      updateStats(filteredRequests);

      // Restore checkbox states
      requestAnimationFrame(() => {
        document.querySelectorAll(".request-checkbox").forEach((checkbox) => {
          const id = checkbox.getAttribute("data-id");
          if (selectedCheckboxes[id]) {
            checkbox.checked = true;
          }
        });
      });

      // If details are open, refresh them
      if (
        selectedRequestId &&
        document.getElementById("requestDetails").style.display === "block"
      ) {
        const selectedRequest = allRequests.find(
          (req) => req.ID === selectedRequestId
        );
        if (selectedRequest) {
          showRequestDetails(selectedRequest);
        }
      }

      // Update memory usage
      updateMemoryUsage();
    } catch (error) {
      console.error("Error parsing SSE data:", error);
    }
  };

  // Apply filters to the requests
  function applyFilters() {
    const connectionTypeFilter = document.getElementById("connection-type-filter").value;
    const methodFilter = document.getElementById("method-filter").value;
    const wsMessageTypeFilter = document.getElementById("ws-message-type-filter").value;
    const wsDirectionFilter = document.getElementById("ws-direction-filter").value;
    const statusFilter = document.getElementById("status-filter").value;
    const pathFilter = document
      .getElementById("path-filter")
      .value.toLowerCase();
    const durationFilter = document.getElementById("duration-filter").value;
    const connectionIdFilter = document.getElementById("connection-id-filter").value.toLowerCase();

    filteredRequests = allRequests.filter((req) => {
      // Connection type filter
      if (connectionTypeFilter && req.ConnectionType !== connectionTypeFilter) {
        return false;
      }

      // Method filter
      if (methodFilter && req.Method !== methodFilter) {
        return false;
      }

      // WebSocket message type filter
      if (wsMessageTypeFilter && req.WebSocketData && req.WebSocketData.MessageType !== wsMessageTypeFilter) {
        return false;
      }

      // WebSocket direction filter  
      if (wsDirectionFilter && req.WebSocketData && req.WebSocketData.Direction !== wsDirectionFilter) {
        return false;
      }

      // Status code filter (only applicable to HTTP requests and WebSocket handshakes)
      if (statusFilter && req.StatusCode) {
        const firstDigit = Math.floor(req.StatusCode / 100);
        if (statusFilter === "2xx" && firstDigit !== 2) return false;
        if (statusFilter === "3xx" && firstDigit !== 3) return false;
        if (statusFilter === "4xx" && firstDigit !== 4) return false;
        if (statusFilter === "5xx" && firstDigit !== 5) return false;
      }

      // Path filter
      if (pathFilter && !req.Path.toLowerCase().includes(pathFilter)) {
        return false;
      }

      // Duration filter
      if (
        durationFilter &&
        (!req.Duration || req.Duration < parseInt(durationFilter))
      ) {
        return false;
      }

      // Connection ID filter (for WebSocket logs)
      if (connectionIdFilter && req.WebSocketData && 
          !req.WebSocketData.ConnectionID.toLowerCase().includes(connectionIdFilter)) {
        return false;
      }

      return true;
    });
  }

  function showMiddlewareTrace(req) {
    const middlewareList = document.getElementById("middleware-tbody");
    middlewareList.innerHTML = "";

    const middlewareChart = document.getElementById("middleware-chart");
    middlewareChart.innerHTML = "";

    if (!req.MiddlewareTrace || req.MiddlewareTrace.length === 0) {
      const row = document.createElement("tr");
      const cell = document.createElement("td");
      cell.colSpan = 5;
      cell.textContent = "No middleware trace available";
      cell.style.textAlign = "center";
      row.appendChild(cell);
      middlewareList.appendChild(row);
      return;
    }

    // Create a timeline visualization
    const totalDuration = req.Duration;
    const timelineStart = new Date(req.MiddlewareTrace[0].start_time);

    // Add timeline axis
    const timelineAxis = document.createElement("div");
    timelineAxis.className = "timeline-axis";

    // Add timeline ticks
    for (let i = 0; i <= 5; i++) {
      const tick = document.createElement("div");
      tick.className = "timeline-tick";
      tick.style.left = i * 20 + "%";

      const label = document.createElement("div");
      label.className = "timeline-label";
      label.style.left = i * 20 + "%";
      label.textContent = Math.round((totalDuration * i) / 5) + " ms";

      timelineAxis.appendChild(tick);
      timelineAxis.appendChild(label);
    }

    middlewareChart.appendChild(timelineAxis);

    // Sort middleware by start time
    const sortedMiddleware = [...req.MiddlewareTrace].sort(
      (a, b) => a.start_time - b.start_time
    );

    // Render middleware bars
    sortedMiddleware.forEach((mw, index) => {
      const startTime = mw.start_time;
      const endTime = mw.end_time || startTime + mw.duration;
      const duration = mw.duration;

      // Calculate position and width for timeline visualization
      const startPos = ((startTime - timelineStart) / totalDuration) * 100;
      const widthPct = (duration / totalDuration) * 100;

      // Create middleware bar
      const bar = document.createElement("div");
      bar.className = "middleware-bar";
      if (mw.error) {
        bar.className += " error";
      }
      bar.style.left = startPos + "%";
      bar.style.width = Math.max(0.5, widthPct) + "%";
      bar.style.top = index * 25 + "px";
      bar.title = `${mw.name}: ${duration}ms`;

      middlewareChart.appendChild(bar);

      // Populate table
      const row = document.createElement("tr");

      const nameCell = document.createElement("td");
      nameCell.textContent = mw.name;
      row.appendChild(nameCell);

      const durationCell = document.createElement("td");
      durationCell.textContent = duration + " ms";
      row.appendChild(durationCell);

      const startTimeCell = document.createElement("td");
      startTimeCell.textContent =
        new Date(startTime).toLocaleTimeString() +
        "." +
        new Date(startTime).getMilliseconds();
      row.appendChild(startTimeCell);

      const endTimeCell = document.createElement("td");
      endTimeCell.textContent =
        new Date(endTime).toLocaleTimeString() +
        "." +
        new Date(endTime).getMilliseconds();
      row.appendChild(endTimeCell);

      const statusCell = document.createElement("td");
      if (mw.error) {
        statusCell.textContent =
          "Error: " + (mw.error_message || "Unknown error");
        statusCell.className = "status-error";
      } else {
        statusCell.textContent = "Success";
        statusCell.className = "status-success";
      }
      row.appendChild(statusCell);

      middlewareList.appendChild(row);
    });

    // Adjust the height of the chart
    middlewareChart.style.height = sortedMiddleware.length * 25 + 30 + "px";
  }

  // Update the table with the request data
  function updateTable(requests) {
    const tbody = document.getElementById("requestsBody");
    tbody.innerHTML = "";

    if (!requests || requests.length === 0) {
      const row = document.createElement("tr");
      const cell = document.createElement("td");
      cell.colSpan = 5;
      cell.textContent = "No requests logged yet";
      cell.style.textAlign = "center";
      row.appendChild(cell);
      tbody.appendChild(row);
      return;
    }

    // Sort requests by timestamp, newest first
    const sortedRequests = [...requests].sort(
      (a, b) => new Date(b.Timestamp) - new Date(a.Timestamp)
    );

    sortedRequests.forEach((req) => {
      const row = document.createElement("tr");
      row.setAttribute("data-id", req.ID);
      row.addEventListener("click", function (e) {
        // Don't navigate if clicking on a checkbox or its container
        if (
          e.target.classList.contains("request-checkbox") ||
          e.target.classList.contains("request-checkbox-container") ||
          e.target.closest(".request-checkbox-container")
        ) {
          return;
        }

        // Navigate to request details section and show details
        document.querySelector('[data-target="requests-section"]').click();
        showRequestDetails(req);
        showRequestTrace(req);
      });

      const timeCell = document.createElement("td");
      timeCell.textContent = new Date(req.Timestamp).toLocaleTimeString();
      row.appendChild(timeCell);

      // Connection type cell
      const typeCell = document.createElement("td");
      const connectionType = req.ConnectionType || "http";
      typeCell.textContent = connectionType.toUpperCase();
      typeCell.className = "connection-type-" + connectionType;
      row.appendChild(typeCell);

      const methodCell = document.createElement("td");
      methodCell.textContent = req.Method;
      // Add CSS class based on method
      methodCell.className = "method-" + req.Method.toLowerCase();
      row.appendChild(methodCell);

      const pathCell = document.createElement("td");
      pathCell.textContent = req.Path + (req.Query ? "?" + req.Query : "");
      row.appendChild(pathCell);

      const statusCell = document.createElement("td");
      if (req.StatusCode) {
        statusCell.textContent = req.StatusCode;
        // Add CSS class based on status code
        if (req.StatusCode >= 200 && req.StatusCode < 300) {
          statusCell.className = "status-success";
        } else if (req.StatusCode >= 300 && req.StatusCode < 400) {
          statusCell.className = "status-redirect";
        } else if (req.StatusCode >= 400 && req.StatusCode < 500) {
          statusCell.className = "status-client-error";
        } else if (req.StatusCode >= 500) {
          statusCell.className = "status-server-error";
        }
      } else {
        statusCell.textContent = "-";
      }
      row.appendChild(statusCell);

      const durationCell = document.createElement("td");
      if (req.Duration !== undefined && req.Duration !== null) {
        durationCell.textContent = req.Duration + " ms";
        // Highlight slow requests
        if (req.Duration > 500) {
          durationCell.className = "status-server-error";
        } else if (req.Duration > 200) {
          durationCell.className = "status-client-error";
        }
      } else {
        durationCell.textContent = "N/A";
      }
      row.appendChild(durationCell);

      // WebSocket info cell
      const wsInfoCell = document.createElement("td");
      if (req.WebSocketData) {
        let wsInfo = "";
        if (req.WebSocketData.ConnectionID) {
          wsInfo += "ID: " + req.WebSocketData.ConnectionID.substring(0, 8) + "...";
        }
        if (req.WebSocketData.MessageType) {
          wsInfo += " | " + req.WebSocketData.MessageType;
        }
        if (req.WebSocketData.Direction) {
          wsInfo += " (" + req.WebSocketData.Direction + ")";
        }
        if (req.WebSocketData.MessageSize) {
          wsInfo += " | " + formatBytes(req.WebSocketData.MessageSize);
        }
        wsInfoCell.textContent = wsInfo;
        wsInfoCell.className = "ws-info";
      } else {
        wsInfoCell.textContent = "-";
      }
      row.appendChild(wsInfoCell);

      tbody.appendChild(row);
    });
  }

  // Update statistics
  function updateStats(requests) {
    if (!requests || requests.length === 0) {
      document.getElementById("stat-total").textContent = "0";
      document.getElementById("stat-success").textContent = "0";
      document.getElementById("stat-redirect").textContent = "0";
      document.getElementById("stat-client-error").textContent = "0";
      document.getElementById("stat-server-error").textContent = "0";
      document.getElementById("stat-avg-time").textContent = "0 ms";

      // Update sidebar stats
      updateSidebarStats(0, 0, 0);
      return;
    }

    let success = 0;
    let redirect = 0;
    let clientError = 0;
    let serverError = 0;
    let totalDuration = 0;
    let validDurationCount = 0;

    requests.forEach((req) => {
      if (req.StatusCode >= 200 && req.StatusCode < 300) success++;
      else if (req.StatusCode >= 300 && req.StatusCode < 400) redirect++;
      else if (req.StatusCode >= 400 && req.StatusCode < 500) clientError++;
      else if (req.StatusCode >= 500) serverError++;

      if (req.Duration !== undefined && req.Duration !== null) {
        totalDuration += req.Duration;
        validDurationCount++;
      }
    });

    const avgDuration =
      validDurationCount > 0
        ? Math.round(totalDuration / validDurationCount)
        : 0;

    const successRate =
      requests.length > 0 ? Math.round((success / requests.length) * 100) : 0;

    document.getElementById("stat-total").textContent = requests.length;
    document.getElementById("stat-success").textContent = success;
    document.getElementById("stat-redirect").textContent = redirect;
    document.getElementById("stat-client-error").textContent = clientError;
    document.getElementById("stat-server-error").textContent = serverError;
    document.getElementById("stat-avg-time").textContent = avgDuration + " ms";

    // Update sidebar stats
    updateSidebarStats(requests.length, successRate, avgDuration);
  }

  // Show request details
  function showRequestDetails(req) {
    selectedRequestId = req.ID;

    document.getElementById("detail-id").textContent = req.ID;
    document.getElementById("detail-time").textContent = new Date(
      req.Timestamp
    ).toLocaleString();
    document.getElementById("detail-method").textContent = req.Method;
    document.getElementById("detail-path").textContent =
      req.Path + (req.Query ? "?" + req.Query : "");
    
    // Show connection type
    const connectionTypeElement = document.getElementById("detail-connection-type");
    if (connectionTypeElement) {
      connectionTypeElement.textContent = (req.ConnectionType || "http").toUpperCase();
    }

    // Show status code (may not exist for WebSocket messages)
    const statusElement = document.getElementById("detail-status");
    if (statusElement) {
      statusElement.textContent = req.StatusCode || "N/A";
    }

    document.getElementById("detail-duration").textContent =
      req.Duration !== undefined && req.Duration !== null
        ? req.Duration + " ms"
        : "N/A";

    // Show WebSocket-specific details if available
    const wsDetailsContainer = document.getElementById("ws-details-container");
    if (wsDetailsContainer) {
      if (req.WebSocketData) {
        wsDetailsContainer.style.display = "block";
        
        const wsConnectionId = document.getElementById("ws-connection-id");
        if (wsConnectionId) {
          wsConnectionId.textContent = req.WebSocketData.ConnectionID || "N/A";
        }

        const wsMessageType = document.getElementById("ws-message-type");
        if (wsMessageType) {
          wsMessageType.textContent = req.WebSocketData.MessageType || "N/A";
        }

        const wsDirection = document.getElementById("ws-direction");
        if (wsDirection) {
          wsDirection.textContent = req.WebSocketData.Direction || "N/A";
        }

        const wsMessageSize = document.getElementById("ws-message-size");
        if (wsMessageSize) {
          wsMessageSize.textContent = req.WebSocketData.MessageSize ? 
            formatBytes(req.WebSocketData.MessageSize) : "N/A";
        }

        const wsSubprotocol = document.getElementById("ws-subprotocol");
        if (wsSubprotocol) {
          wsSubprotocol.textContent = req.WebSocketData.Subprotocol || "None";
        }

        const wsIsHandshake = document.getElementById("ws-is-handshake");
        if (wsIsHandshake) {
          wsIsHandshake.textContent = req.WebSocketData.IsHandshake ? "Yes" : "No";
        }
      } else {
        wsDetailsContainer.style.display = "none";
      }
    }

    // Try to add replay button safely
    try {
      const detailHeader = document.querySelector(
        "#requestDetails .card-header"
      );
      if (detailHeader && !document.getElementById("replayRequestBtn")) {
        const replayBtn = document.createElement("button");
        replayBtn.id = "replayRequestBtn";
        replayBtn.className = "btn";
        replayBtn.style.marginLeft = "10px";
        replayBtn.textContent = "Replay Request";
        replayBtn.addEventListener("click", () => {
          openReplayModal(req);
        });
        detailHeader.appendChild(replayBtn);
      }
    } catch (e) {
      console.error("Could not add replay button:", e);
    }

    // Format headers
    const requestHeaders = formatHeaders(req.RequestHeaders);
    const responseHeaders = formatHeaders(req.ResponseHeaders);

    document.getElementById("detail-request-headers").textContent =
      requestHeaders || "No headers available";
    document.getElementById("detail-response-headers").textContent =
      responseHeaders || "No headers available";

    // Handle request and response bodies
    const requestBodyContainer = document.getElementById(
      "request-body-container"
    );
    const responseBodyContainer = document.getElementById(
      "response-body-container"
    );
    const requestBodyElement = document.getElementById("detail-request-body");
    const responseBodyElement = document.getElementById("detail-response-body");

    if (req.RequestBody) {
      requestBodyContainer.style.display = "block";
      requestBodyElement.textContent = formatBody(req.RequestBody);
    } else {
      requestBodyContainer.style.display = "none";
    }

    if (req.ResponseBody) {
      responseBodyContainer.style.display = "block";
      responseBodyElement.textContent = formatBody(req.ResponseBody);
    } else {
      responseBodyContainer.style.display = "none";
    }

    // Show the details
    document.getElementById("requestDetails").style.display = "block";
  }

  // Show request trace
  function showRequestTrace(req) {
    const traceContainer = document.getElementById("traceContainer");
    traceContainer.style.display = "block";

    // Update the trace timing information
    document.getElementById("trace-total-time").textContent = req.Duration
      ? req.Duration + " ms"
      : "N/A";

    // These values would be populated if we had more detailed timing data
    const duration = req.Duration || 0;
    document.getElementById("trace-ttfb").textContent =
      Math.round(duration * 0.2) + " ms";
    document.getElementById("trace-network-time").textContent =
      Math.round(duration * 0.1) + " ms";
    document.getElementById("trace-processing-time").textContent =
      Math.round(duration * 0.7) + " ms";

    // Populate timeline (would need more detailed timing data)
    const timelineContent = document.getElementById("timeline-content");
    timelineContent.innerHTML = "";

    // Example phases - in a real implementation, this would come from detailed tracing
    const phases = [
      { name: "Connection", duration: Math.round(duration * 0.05) },
      { name: "Request Processing", duration: Math.round(duration * 0.15) },
      { name: "Handler Execution", duration: Math.round(duration * 0.7) },
      { name: "Response Generation", duration: Math.round(duration * 0.1) },
    ];

    phases.forEach((phase) => {
      const timelineItem = document.createElement("div");
      timelineItem.className = "timeline-item";

      const phaseName = document.createElement("div");
      phaseName.textContent = phase.name;

      const phaseDuration = document.createElement("div");
      phaseDuration.textContent = phase.duration + " ms";

      timelineItem.appendChild(phaseName);
      timelineItem.appendChild(phaseDuration);
      timelineContent.appendChild(timelineItem);
    });

    // Show middleware trace
    showMiddlewareTrace(req);

    // Show route trace if available
    if (req.RouteTrace) {
      document.getElementById("trace-route-match").style.display = "block";
      const routeDetails = document.getElementById("trace-route-details");
      routeDetails.innerHTML = "";

      const routePattern = document.createElement("div");
      routePattern.className = "trace-detail-item";
      routePattern.innerHTML = `<strong>Pattern:</strong> ${
        req.RouteTrace.pattern || "Unknown"
      }`;
      routeDetails.appendChild(routePattern);

      const routePath = document.createElement("div");
      routePath.className = "trace-detail-item";
      routePath.innerHTML = `<strong>Path:</strong> ${
        req.RouteTrace.path || "Unknown"
      }`;
      routeDetails.appendChild(routePath);

      if (req.RouteTrace.params) {
        const paramsTitle = document.createElement("div");
        paramsTitle.className = "trace-detail-item";
        paramsTitle.innerHTML = `<strong>Parameters:</strong>`;
        routeDetails.appendChild(paramsTitle);

        const paramsList = document.createElement("ul");
        paramsList.className = "route-params-list";

        for (const [key, value] of Object.entries(req.RouteTrace.params)) {
          const paramItem = document.createElement("li");
          paramItem.innerHTML = `<strong>${key}:</strong> ${value}`;
          paramsList.appendChild(paramItem);
        }

        routeDetails.appendChild(paramsList);
      }
    } else {
      document.getElementById("trace-route-match").style.display = "none";
    }
  }

  // Format headers for display
  function formatHeaders(headers) {
    if (!headers) return "";

    let result = "";
    for (const key in headers) {
      result += `${key}: ${headers[key].join(", ")}\n`;
    }
    return result;
  }

  // Format body for display
  function formatBody(body) {
    try {
      // Try to parse and pretty-print JSON
      const json = JSON.parse(body);
      return JSON.stringify(json, null, 2);
    } catch (e) {
      // If not JSON, return as-is
      return body;
    }
  }

  // Update memory usage (simulated for now)
  function updateMemoryUsage() {
    // In a real implementation, this would get data from the server
    const usedMemory = Math.random() * 2000; // Simulated memory usage (MB)
    const totalMemory = 8192; // Simulated total memory (MB)
    const percentage = (usedMemory / totalMemory) * 100;

    document.getElementById("memory-used").style.width = percentage + "%";
    document.getElementById("memory-used-value").textContent =
      Math.round(usedMemory) + " MB";
    document.getElementById("memory-total").textContent =
      Math.round(totalMemory) + " MB";
  }

  // Toggle collapse function for collapsible sections
  function toggleCollapse(element) {
    const card = element.closest(".collapsible");
    card.classList.toggle("collapsed");
  }

  // Close details
  document.getElementById("close-details").addEventListener("click", () => {
    document.getElementById("requestDetails").style.display = "none";
    document.getElementById("traceContainer").style.display = "none";
    selectedRequestId = null;

    // Return to dashboard section
    document.querySelector('[data-target="dashboard-section"]').click();
  });

  // Clear all requests function
  function clearAllRequests() {
    if (confirm("Are you sure you want to clear all requests?")) {
      // In a real implementation, this would call an API endpoint to clear the requests
      fetch("/__viz/api/clear", {
        method: "POST",
      })
        .then((response) => {
          if (response.ok) {
            // Clear local data
            allRequests = [];
            filteredRequests = [];
            updateTable(filteredRequests);
            updateStats(filteredRequests);

            // Hide details if open
            document.getElementById("requestDetails").style.display = "none";
            document.getElementById("traceContainer").style.display = "none";
            selectedRequestId = null;
          }
        })
        .catch((error) => console.error("Error clearing requests:", error));
    }
  }

  // Set up filter actions
  document.getElementById("apply-filters").addEventListener("click", () => {
    applyFilters();
    updateTable(filteredRequests);
    updateStats(filteredRequests);
  });

  document.getElementById("reset-filters").addEventListener("click", () => {
    // Reset filter inputs
    document.getElementById("connection-type-filter").value = "";
    document.getElementById("method-filter").value = "";
    document.getElementById("ws-message-type-filter").value = "";
    document.getElementById("ws-direction-filter").value = "";
    document.getElementById("status-filter").value = "";
    document.getElementById("path-filter").value = "";
    document.getElementById("duration-filter").value = "";
    document.getElementById("connection-id-filter").value = "";

    // Reset filtered data
    filteredRequests = [...allRequests];
    updateTable(filteredRequests);
    updateStats(filteredRequests);
  });

  // Helper function to format bytes
  function formatBytes(bytes, decimals = 2) {
    if (bytes === 0) return '0 Bytes';

    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];

    const i = Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
  }

  document
    .getElementById("clear-requests")
    .addEventListener("click", clearAllRequests);

  // Initial memory usage update
  updateMemoryUsage();

  // Set up periodic memory usage updates
  setInterval(updateMemoryUsage, 5000);

  // Request comparison functionality
  let selectedRequests = [];
  const maxCompareRequests = 2; // Maximum number of requests to compare

  // Add checkbox to request rows for selection
  function addSelectionToTable() {
    const rows = document.querySelectorAll("#requestsBody tr");
    rows.forEach((row) => {
      // Skip rows that don't have data
      if (!row.hasAttribute("data-id")) {
        return;
      }

      // Don't add checkboxes twice
      if (row.querySelector(".request-checkbox")) {
        return;
      }

      const requestId = row.getAttribute("data-id");
      const firstCell = row.querySelector("td:first-child");

      // Create checkbox container
      const checkboxContainer = document.createElement("div");
      checkboxContainer.style.display = "inline-block";
      checkboxContainer.style.marginRight = "10px";
      checkboxContainer.className = "request-checkbox-container";

      // Prevent event bubbling for the container
      checkboxContainer.addEventListener("click", function (e) {
        e.stopPropagation();
      });

      // Create checkbox
      const checkbox = document.createElement("input");
      checkbox.type = "checkbox";
      checkbox.className = "request-checkbox";
      checkbox.setAttribute("data-id", requestId);

      // Check if this request is already in selectedRequests
      if (selectedRequests.includes(requestId)) {
        checkbox.checked = true;
        row.classList.add("selected-for-comparison");
      }

      // Handle checkbox events
      checkbox.addEventListener("click", function (e) {
        e.stopPropagation(); // This is critical - stop click from bubbling to parent row
      });

      checkbox.addEventListener("change", function (e) {
        e.stopPropagation();
        toggleRequestSelection(requestId);
      });

      // Add to DOM
      checkboxContainer.appendChild(checkbox);
      firstCell.insertBefore(checkboxContainer, firstCell.firstChild);
    });
  }

  // Toggle request selection
  function toggleRequestSelection(requestId) {
    const index = selectedRequests.indexOf(requestId);
    const row = document.querySelector(`tr[data-id="${requestId}"]`);

    if (index === -1) {
      // Add to selection if not already at maximum
      if (selectedRequests.length < maxCompareRequests) {
        selectedRequests.push(requestId);
        addToSelectedList(requestId);
        if (row) row.classList.add("selected-for-comparison");
      } else {
        alert(
          `Maximum of ${maxCompareRequests} requests can be compared at once.`
        );
        // Uncheck the checkbox
        document.querySelector(
          `.request-checkbox[data-id="${requestId}"]`
        ).checked = false;
        return;
      }
    } else {
      // Remove from selection
      selectedRequests.splice(index, 1);
      removeFromSelectedList(requestId);
      if (row) row.classList.remove("selected-for-comparison");
    }

    updateCompareButton();
  }

  // Add request to the selected list
  function addToSelectedList(requestId) {
    const selectedList = document.getElementById("selectedRequestsList");
    const placeholder = document.querySelector(".compare-placeholder");

    if (placeholder) {
      placeholder.remove();
    }

    // Find the request in allRequests
    const request = allRequests.find((req) => req.ID === requestId);
    if (!request) return;

    const item = document.createElement("div");
    item.className = "compare-item";
    item.setAttribute("data-id", requestId);
    item.innerHTML = `
            <span>${request.Method} ${request.Path}</span>
            <span class="remove-item" data-id="${requestId}">&times;</span>
        `;

    item.querySelector(".remove-item").addEventListener("click", function () {
      const id = this.getAttribute("data-id");
      // Uncheck the checkbox
      const checkbox = document.querySelector(
        `.request-checkbox[data-id="${id}"]`
      );
      if (checkbox) checkbox.checked = false;
      toggleRequestSelection(id);
    });

    selectedList.appendChild(item);
  }

  // Remove request from the selected list
  function removeFromSelectedList(requestId) {
    const item = document.querySelector(
      `.compare-item[data-id="${requestId}"]`
    );
    if (item) {
      item.remove();
    }

    // Show placeholder if no items left
    const selectedList = document.getElementById("selectedRequestsList");
    if (selectedList.children.length === 0) {
      const placeholder = document.createElement("div");
      placeholder.className = "compare-placeholder";
      placeholder.textContent = "Select 2 or more requests to compare";
      selectedList.appendChild(placeholder);
    }
  }

  // Update the compare button visibility
  function updateCompareButton() {
    const compareBtn = document.getElementById("diff-compare-btn");

    if (selectedRequests.length >= 2) {
      compareBtn.classList.add("active");
      document.getElementById("comparePanel").style.display = "block";
    } else {
      compareBtn.classList.remove("active");
    }
  }

  // Run the comparison
  function runComparison() {
    if (selectedRequests.length < 2) {
      alert("Please select at least 2 requests to compare.");
      return;
    }

    // Build query string with selected request IDs
    const queryString = selectedRequests.map((id) => `id=${id}`).join("&");

    // Fetch comparison data
    fetch(`/__viz/api/compare?${queryString}`)
      .then((response) => response.json())
      .then((requests) => {
        displayComparison(requests);
      })
      .catch((error) => {
        console.error("Error fetching comparison data:", error);
        alert("An error occurred while fetching comparison data.");
      });
  }

  // Display the comparison
  function displayComparison(requests) {
    const resultsContainer = document.getElementById("comparisonResults");
    resultsContainer.innerHTML = "";

    if (requests.length < 2) {
      resultsContainer.innerHTML = "<p>Not enough requests for comparison.</p>";
      return;
    }

    // Check if we have potentially related routes (same pattern with different parameters)
    const routePatterns = detectRoutePatterns(requests);
    const hasRelatedRoutes = Object.keys(routePatterns).length > 0;

    // Create a column for each request
    requests.forEach((request, index) => {
      const column = document.createElement("div");
      column.className = "compare-column";

      // Column header
      const header = document.createElement("div");
      header.className = "compare-column-header";
      header.textContent = `${request.Method} ${request.Path}`;
      if (index === 0) {
        header.textContent += " (Base for comparison)";
      }
      column.appendChild(header);

      // Column content
      const content = document.createElement("div");
      content.className = "compare-column-content";

      // Add basic details
      addCompareDetailRow(content, "ID", request.ID);
      addCompareDetailRow(content, "Method", request.Method);
      addCompareDetailRow(content, "Path", request.Path);

      // Add route pattern information if available
      if (hasRelatedRoutes) {
        const patternKey = findPatternForRequest(routePatterns, request.Path);
        if (patternKey) {
          const pattern = routePatterns[patternKey].pattern;
          const params = extractRouteParams(pattern, request.Path);

          if (pattern) {
            addCompareDetailRow(content, "Route Pattern", pattern);
          }

          if (params && Object.keys(params).length > 0) {
            let paramsText = "";
            for (const [key, value] of Object.entries(params)) {
              paramsText += `${key}: ${value}\n`;
            }
            addCompareDetailRow(content, "Route Parameters", paramsText);
          }
        }
      }

      // Continue with other details
      addCompareDetailRow(content, "Status", request.StatusCode);
      addCompareDetailRow(content, "Time", `${request.Duration} ms`);
      addCompareDetailRow(
        content,
        "Timestamp",
        new Date(request.Timestamp).toLocaleString()
      );

      // Add request headers
      if (request.RequestHeaders) {
        if (index === 0 || !requests[0].RequestHeaders) {
          addCompareDetailRow(
            content,
            "Request Headers",
            formatHeaders(request.RequestHeaders)
          );
        } else {
          // Compare with first request's headers
          addCompareDetailRow(
            content,
            "Request Headers",
            compareHeaders(requests[0].RequestHeaders, request.RequestHeaders)
          );
        }
      }

      // Add response headers
      if (request.ResponseHeaders) {
        if (index === 0 || !requests[0].ResponseHeaders) {
          addCompareDetailRow(
            content,
            "Response Headers",
            formatHeaders(request.ResponseHeaders)
          );
        } else {
          // Compare with first request's headers
          addCompareDetailRow(
            content,
            "Response Headers",
            compareHeaders(requests[0].ResponseHeaders, request.ResponseHeaders)
          );
        }
      }

      // Add request body with JSON diff if possible
      if (request.RequestBody) {
        if (index === 0 || !requests[0].RequestBody) {
          addCompareDetailRow(
            content,
            "Request Body",
            formatBody(request.RequestBody)
          );
        } else {
          try {
            // Try to parse as JSON for diff
            const baseJson = JSON.parse(requests[0].RequestBody);
            const currentJson = JSON.parse(request.RequestBody);
            addCompareDetailRow(
              content,
              "Request Body (with diffs)",
              formatJsonDiff(baseJson, currentJson)
            );
          } catch (e) {
            // Fall back to regular display if not valid JSON
            addCompareDetailRow(
              content,
              "Request Body",
              formatBody(request.RequestBody)
            );
          }
        }
      }

      // Add response body with JSON diff if possible
      if (request.ResponseBody) {
        if (index === 0 || !requests[0].ResponseBody) {
          addCompareDetailRow(
            content,
            "Response Body",
            formatBody(request.ResponseBody)
          );
        } else {
          try {
            // Try to parse as JSON for diff
            const baseJson = JSON.parse(requests[0].ResponseBody);
            const currentJson = JSON.parse(request.ResponseBody);
            addCompareDetailRow(
              content,
              "Response Body (with diffs)",
              formatJsonDiff(baseJson, currentJson)
            );
          } catch (e) {
            // Fall back to regular display if not valid JSON
            addCompareDetailRow(
              content,
              "Response Body",
              formatBody(request.ResponseBody)
            );
          }
        }
      }

      column.appendChild(content);
      resultsContainer.appendChild(column);
    });

    // Show the comparison panel
    document.getElementById("comparePanel").classList.add("active");
  }

  // Compare headers and highlight differences
  function compareHeaders(baseHeaders, compareHeaders) {
    let result = "";
    const allKeys = new Set();

    // Collect all keys from both objects
    for (const key in baseHeaders) allKeys.add(key);
    for (const key in compareHeaders) allKeys.add(key);

    // Sort keys alphabetically
    const sortedKeys = Array.from(allKeys).sort();

    sortedKeys.forEach((key) => {
      const baseValue = baseHeaders[key]
        ? baseHeaders[key].join(", ")
        : undefined;
      const compareValue = compareHeaders[key]
        ? compareHeaders[key].join(", ")
        : undefined;

      if (!baseValue) {
        // New header in the comparison
        result += `<span class="diff-add">${key}: ${compareValue}</span>\n`;
      } else if (!compareValue) {
        // Header removed in the comparison
        result += `${key}: [removed]\n`;
      } else if (baseValue !== compareValue) {
        // Header value changed
        result += `${key}: <span class="diff-highlight">${compareValue}</span>\n`;
      } else {
        // Same value
        result += `${key}: ${compareValue}\n`;
      }
    });

    return result;
  }

  // Format JSON diff
  function formatJsonDiff(baseJson, compareJson, path = "") {
    let output = "";

    if (Array.isArray(baseJson) && Array.isArray(compareJson)) {
      // Handle arrays
      const maxLength = Math.max(baseJson.length, compareJson.length);

      output += "[\n";
      for (let i = 0; i < maxLength; i++) {
        const currentPath = path ? `${path}[${i}]` : `[${i}]`;
        const indent = "  ".repeat(currentPath.split(/[\[\].]+/).length);

        if (i < baseJson.length && i < compareJson.length) {
          // Both arrays have this index
          output += indent;
          if (
            typeof baseJson[i] === "object" &&
            baseJson[i] !== null &&
            typeof compareJson[i] === "object" &&
            compareJson[i] !== null
          ) {
            // Both are objects, recursively diff
            output += formatJsonDiff(baseJson[i], compareJson[i], currentPath);
          } else if (baseJson[i] !== compareJson[i]) {
            // Primitive values that differ
            output += `<span class="diff-highlight">${JSON.stringify(
              compareJson[i]
            )}</span>`;
          } else {
            // Same values
            output += JSON.stringify(compareJson[i]);
          }
        } else if (i >= baseJson.length) {
          // Item only in compareJson
          output +=
            indent +
            `<span class="diff-add">${JSON.stringify(compareJson[i])}</span>`;
        } else {
          // Item in baseJson but not in compareJson
          output += indent + `[removed]`;
        }

        if (i < maxLength - 1) {
          output += ",";
        }
        output += "\n";
      }
      output += "  ".repeat(path.split(/[\[\].]+/).length - 1) + "]";
    } else if (
      typeof baseJson === "object" &&
      baseJson !== null &&
      typeof compareJson === "object" &&
      compareJson !== null
    ) {
      // Handle objects
      const allKeys = new Set();
      Object.keys(baseJson).forEach((key) => allKeys.add(key));
      Object.keys(compareJson).forEach((key) => allKeys.add(key));

      const sortedKeys = Array.from(allKeys).sort();

      output += "{\n";
      sortedKeys.forEach((key, index) => {
        const currentPath = path ? `${path}.${key}` : key;
        const indent = "  ".repeat(currentPath.split(/[\[\].]+/).length);

        output += indent + `"${key}": `;

        if (key in baseJson && key in compareJson) {
          // Key in both objects
          if (
            typeof baseJson[key] === "object" &&
            baseJson[key] !== null &&
            typeof compareJson[key] === "object" &&
            compareJson[key] !== null
          ) {
            // Both are objects, recursively diff
            output += formatJsonDiff(
              baseJson[key],
              compareJson[key],
              currentPath
            );
          } else if (baseJson[key] !== compareJson[key]) {
            // Primitive values that differ
            output += `<span class="diff-highlight">${JSON.stringify(
              compareJson[key]
            )}</span>`;
          } else {
            // Same values
            output += JSON.stringify(compareJson[key]);
          }
        } else if (!(key in baseJson)) {
          // Key only in compareJson
          output += `<span class="diff-add">${JSON.stringify(
            compareJson[key]
          )}</span>`;
        } else {
          // Key in baseJson but not in compareJson
          output += `[removed]`;
        }

        if (index < sortedKeys.length - 1) {
          output += ",";
        }
        output += "\n";
      });
      output += "  ".repeat(path.split(/[\[\].]+/).length - 1) + "}";
    } else {
      // Handle primitive values
      if (baseJson !== compareJson) {
        output += `<span class="diff-highlight">${JSON.stringify(
          compareJson
        )}</span>`;
      } else {
        output += JSON.stringify(compareJson);
      }
    }

    return output;
  }

  // Add a detail row to the comparison
  function addCompareDetailRow(container, label, value) {
    const row = document.createElement("div");
    row.className = "compare-detail-row";

    const labelElement = document.createElement("div");
    labelElement.className = "compare-detail-label";
    labelElement.textContent = label;

    const valueElement = document.createElement("div");
    valueElement.className = "compare-detail-value";

    if (typeof value === "string") {
      // Check if value contains HTML for diff highlighting
      if (value.includes("<span class=")) {
        if (value.includes("\n")) {
          // Multiline HTML content
          const pre = document.createElement("pre");
          pre.innerHTML = value;
          valueElement.appendChild(pre);
        } else {
          // Single line HTML content
          valueElement.innerHTML = value;
        }
      } else if (value.includes("\n")) {
        // Regular multiline text, use pre element
        const pre = document.createElement("pre");
        pre.textContent = value;
        valueElement.appendChild(pre);
      } else {
        // Regular single line text
        valueElement.textContent = value;
      }
    } else {
      valueElement.textContent = value;
    }

    row.appendChild(labelElement);
    row.appendChild(valueElement);
    container.appendChild(row);
  }

  // Event Listeners
  document
    .getElementById("diff-compare-btn")
    .addEventListener("click", function () {
      document.getElementById("comparePanel").classList.add("active");
    });

  document
    .getElementById("closeCompare")
    .addEventListener("click", function () {
      document.getElementById("comparePanel").classList.remove("active");
    });

  document
    .getElementById("runComparison")
    .addEventListener("click", runComparison);

  // Initialize comparison UI
  function initComparisonUI() {
    addSelectionToTable();
  }

  // Call initialization after table updates
  const originalUpdateTable = updateTable;
  updateTable = function (requests) {
    originalUpdateTable(requests);
    initComparisonUI();
  };

  // Initialize on page load
  initComparisonUI();

  // Detect route patterns in the requests
  function detectRoutePatterns(requests) {
    const patterns = {};

    // Example path patterns to detect:
    // /api/users/123 and /api/users/456 => /api/users/:id
    // /api/products/electronics/tv and /api/products/furniture/chair => /api/products/:category/:item

    // Simple rule-based pattern detection - this could be improved with more sophisticated algorithms
    requests.forEach((req) => {
      const path = req.Path;
      const segments = path.split("/").filter(Boolean);

      // Look for numeric segments (likely IDs)
      for (let i = 0; i < segments.length; i++) {
        if (/^\d+$/.test(segments[i])) {
          // Create a pattern with this segment replaced by :id
          const patternSegments = [...segments];
          patternSegments[i] = ":id";
          const pattern = "/" + patternSegments.join("/");

          // Store the pattern
          if (!patterns[pattern]) {
            patterns[pattern] = {
              pattern: pattern,
              paths: [],
            };
          }

          patterns[pattern].paths.push(path);
          break; // Only detect one parameter per path for now
        }

        // Look for UUID-like segments
        if (
          /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(
            segments[i]
          )
        ) {
          // Create a pattern with this segment replaced by :uuid
          const patternSegments = [...segments];
          patternSegments[i] = ":uuid";
          const pattern = "/" + patternSegments.join("/");

          // Store the pattern
          if (!patterns[pattern]) {
            patterns[pattern] = {
              pattern: pattern,
              paths: [],
            };
          }

          patterns[pattern].paths.push(path);
          break;
        }
      }
    });

    // Only return patterns that match multiple paths
    return Object.fromEntries(
      Object.entries(patterns).filter(([_, value]) => value.paths.length > 1)
    );
  }

  // Find the pattern for a specific request path
  function findPatternForRequest(patterns, path) {
    for (const [patternKey, patternData] of Object.entries(patterns)) {
      if (patternData.paths.includes(path)) {
        return patternKey;
      }
    }
    return null;
  }

  // Extract route parameters from a path based on a pattern
  function extractRouteParams(pattern, path) {
    const patternSegments = pattern.split("/").filter(Boolean);
    const pathSegments = path.split("/").filter(Boolean);

    if (patternSegments.length !== pathSegments.length) {
      return null;
    }

    const params = {};

    for (let i = 0; i < patternSegments.length; i++) {
      if (patternSegments[i].startsWith(":")) {
        const paramName = patternSegments[i].substring(1);
        params[paramName] = pathSegments[i];
      }
    }

    return params;
  }

  // Open replay modal with request data
  function openReplayModal(req) {
    // Set request ID
    document.getElementById("replayRequestId").value = req.ID;

    // Set URL (combine path and query)
    const url =
      window.location.origin + req.Path + (req.Query ? `?${req.Query}` : "");
    document.getElementById("replayUrl").value = url;

    // Set method
    document.getElementById("replayMethod").value = req.Method;

    // Populate headers
    const headersBody = document.getElementById("replayHeadersBody");
    headersBody.innerHTML = "";

    if (req.RequestHeaders) {
      for (const [key, values] of Object.entries(req.RequestHeaders)) {
        // Skip certain headers that browsers control
        if (
          [
            "Host",
            "Connection",
            "Upgrade-Insecure-Requests",
            "Sec-Fetch-",
            "Accept-Encoding",
          ].some((h) => key.startsWith(h))
        ) {
          continue;
        }

        addHeaderRow(key, values.join(", "));
      }
    }

    // Set body
    document.getElementById("replayBody").value = req.RequestBody || "";

    // Reset result section
    document.getElementById("replayResult").classList.remove("active");

    // Show modal
    document.getElementById("replayModal").classList.add("active");
  }

  // Add a header row to the table
  function addHeaderRow(name = "", value = "") {
    const headersBody = document.getElementById("replayHeadersBody");
    const row = document.createElement("tr");

    row.innerHTML = `
        <td><input type="text" class="header-name" value="${escapeHtml(
          name
        )}" placeholder="Header name"></td>
        <td><input type="text" class="header-value" value="${escapeHtml(
          value
        )}" placeholder="Header value"></td>
        <td><span class="replay-remove-header">&times;</span></td>
    `;

    row
      .querySelector(".replay-remove-header")
      .addEventListener("click", function () {
        row.remove();
      });

    headersBody.appendChild(row);
  }

  // Send the replay request
  function sendReplayRequest(e) {
    e.preventDefault();

    // Collect form data
    const requestId = document.getElementById("replayRequestId").value;
    const url = document.getElementById("replayUrl").value;
    const method = document.getElementById("replayMethod").value;
    const body = document.getElementById("replayBody").value;

    // Collect headers
    const headers = {};
    const headerRows = document.querySelectorAll("#replayHeadersBody tr");
    headerRows.forEach((row) => {
      const nameInput = row.querySelector(".header-name");
      const valueInput = row.querySelector(".header-value");

      if (nameInput.value) {
        headers[nameInput.value] = valueInput.value;
      }
    });

    // Prepare request data
    const requestData = {
      requestId,
      url,
      method,
      headers,
      body,
    };

    // Show loading
    const sendButton = document.getElementById("sendReplayRequest");
    const originalText = sendButton.textContent;
    sendButton.innerHTML = '<span class="replay-spinner"></span> Sending...';
    sendButton.disabled = true;

    // Send request to server
    fetch("/__viz/api/replay", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestData),
    })
      .then((response) => response.json())
      .then((data) => {
        // Display results
        displayReplayResult(data);
      })
      .catch((error) => {
        console.error("Error replaying request:", error);
        alert("Error replaying request: " + error.message);
      })
      .finally(() => {
        // Reset button
        sendButton.innerHTML = originalText;
        sendButton.disabled = false;
      });
  }

  // Display replay results
  function displayReplayResult(data) {
    // Show result section
    const resultSection = document.getElementById("replayResult");
    resultSection.classList.add("active");

    // Set status info
    const statusElement = document.getElementById("replayResponseStatus");
    const statusBadge = document.getElementById("replayStatusBadge");
    statusElement.textContent = `${data.statusCode} ${getStatusText(
      data.statusCode
    )}`;

    if (data.statusCode >= 200 && data.statusCode < 300) {
      statusBadge.textContent = "Success";
      statusBadge.className = "replay-status replay-status-success";
    } else {
      statusBadge.textContent = "Error";
      statusBadge.className = "replay-status replay-status-error";
    }

    // Set duration
    document.getElementById("replayResponseDuration").textContent =
      data.duration;

    // Set headers
    const headersText = formatHeadersForDisplay(data.headers);
    document.getElementById("replayResponseHeaders").textContent = headersText;

    // Set body
    const bodyElement = document.getElementById("replayResponseBody");

    try {
      // Try to format as JSON if possible
      const json = JSON.parse(data.body);
      bodyElement.textContent = JSON.stringify(json, null, 2);
    } catch (e) {
      // Not JSON, display as is
      bodyElement.textContent = data.body;
    }

    // Scroll to results
    resultSection.scrollIntoView({ behavior: "smooth" });
  }

  // Format headers for display in the replay results
  function formatHeadersForDisplay(headers) {
    if (!headers) return "No headers";

    let output = "";
    for (const [key, values] of Object.entries(headers)) {
      output += `${key}: ${
        Array.isArray(values) ? values.join(", ") : values
      }\n`;
    }

    return output;
  }

  // Get HTTP status text
  function getStatusText(code) {
    const statusTexts = {
      100: "Continue",
      101: "Switching Protocols",
      200: "OK",
      201: "Created",
      202: "Accepted",
      204: "No Content",
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Found",
      304: "Not Modified",
      400: "Bad Request",
      401: "Unauthorized",
      403: "Forbidden",
      404: "Not Found",
      405: "Method Not Allowed",
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
    };

    return statusTexts[code] || "";
  }

  // HTML escape helper
  function escapeHtml(str) {
    if (!str) return "";
    return str
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  // Set up event listeners for replay modal
  document.getElementById("addHeaderRow").addEventListener("click", () => {
    addHeaderRow();
  });

  document
    .getElementById("replayForm")
    .addEventListener("submit", sendReplayRequest);

  document.getElementById("closeReplayModal").addEventListener("click", () => {
    document.getElementById("replayModal").classList.remove("active");
  });

  // Close modal if clicking outside the content
  document.getElementById("replayModal").addEventListener("click", (e) => {
    if (e.target === document.getElementById("replayModal")) {
      document.getElementById("replayModal").classList.remove("active");
    }
  });
</script>
{{end}}
